import os
from model import  *
 

#this might be better implemented as a 'Node' in scons, but 
#I want to get something working before exploring that path
# This is going to recursively build all the bsvs
class WrapperGen():

  def __init__(self, moduleList):

    ## Here we use a module list sorted alphabetically in order to guarantee
    ## the generated wrapper files are consistent.  The topological sort
    ## guarantees only a depth first traversal -- not the same traversal
    ## each time.
    synth_modules = [moduleList.topModule] + moduleList.synthBoundaries()

    for module in synth_modules:
      modPath = moduleList.env['DEFS']['ROOT_DIR_HW'] + '/' + module.buildPath + '/' + module.name
      wrapperPath =  modPath + "_Wrapper.bsv"
      logPath = modPath + "_Log.bsv"
      conSizePath =  modPath + "_Wrapper_con_size.bsh"
      ignorePath = moduleList.env['DEFS']['ROOT_DIR_HW'] + '/' + module.buildPath + '/.ignore'

      if(getBuildPipelineDebug(moduleList) != 0):
        print "Wrapper path is " + wrapperPath
      wrapper_bsv = open(wrapperPath, 'w')

      ignore_bsv = open(ignorePath, 'w')
      ignore_bsv.write("// Generated by wrapper_gen.py\n\n")

      # Connection size doesn't appear on the first dependence pass, since it
      # doesn't exist until after the first build.  Finding it later results in
      # build dependence changes and rebuilding.  Ignore it, since the file will
      # change only when some other file changes.
      ignore_bsv.write(conSizePath);
      ignore_bsv.close();

      # Generate a dummy connection size file to avoid errors during dependence
      # analysis.
      if not os.path.exists(conSizePath):
        os.system('leap-connect --dummy --dynsize ' + module.name + ' ' + conSizePath)

      wrapper_bsv.write('import HList::*;\n')
      wrapper_bsv.write('import ModuleContext::*;\n')
      # the top module is handled specially
      if(module.name == moduleList.topModule.name):

        wrapper_bsv.write('// These are well-known/required leap modules\n')
        wrapper_bsv.write('// import non-synthesis public files\n')
        wrapper_bsv.write('`include "' + module.name + '.bsv"\n')

        # Include all subordinate synthesis boundaries for use by
        # instantiateAllSynthBoundaries() below.
        for synth in synth_modules:
          if synth != module:
            wrapper_bsv.write('`include "' + synth.name + '_synth.bsv"\n')

        wrapper_bsv.write('\n// import non-synthesis private files\n')
        wrapper_bsv.write('// Get defintion of TOP_LEVEL_WIRES\n')
        wrapper_bsv.write('import physical_platform::*;\n')
        wrapper_bsv.write('(* synthesize *)\n')
        wrapper_bsv.write('(* no_default_clock, no_default_reset *)\n')
        wrapper_bsv.write('module [Module] mk_model_Wrapper (TOP_LEVEL_WIRES);\n')
        wrapper_bsv.write('    // instantiate own module\n')
        wrapper_bsv.write('     let m <- mkModel();\n')
        wrapper_bsv.write('    return m;\n')
        wrapper_bsv.write('endmodule\n')

        # Provide a method that imports all subordinate synthesis boundaries.
        # It will be invoked inside the top level model in order to build
        # all soft connections.
        wrapper_bsv.write('\n\nmodule ')
        if len(synth_modules) != 1:
          wrapper_bsv.write('[Connected_Module]')
        wrapper_bsv.write(' instantiateAllSynthBoundaries ();\n')

        for synth in synth_modules:
          if synth != module:
            wrapper_bsv.write('    ' + synth.synthBoundaryModule + '();\n')

        wrapper_bsv.write('endmodule')
      else:
        log_bsv = open(logPath, 'w')
        log_bsv.write('import HList::*;\n')
        log_bsv.write('import ModuleContext::*;\n')

        # Parents of a synthesis boundary likely import the top level module of
        # the boundary.  This way, the synthesis boundary could be removed and
        # the code within the boundary would be imported correctly by the parent.
        # The code within the synthesis boundary will actually be imported at the
        # top level instead, so we need a dummy module for use by the parent of
        # a boundary that looks like it imports the code but actually does nothing.
        # Importing at the top level allows us to build all synthesis regions
        # in parallel.
        dummy_import_bsv = open(modPath + '.bsv', 'w')
        dummy_import_bsv.write('// Generated by wrapper_gen.py\n\n')
        dummy_import_bsv.write('module ' + module.synthBoundaryModule + ' ();\n');
        dummy_import_bsv.write('endmodule\n');
        dummy_import_bsv.close()

        if not os.path.exists(modPath + '_synth.bsv'):
          os.system('leap-connect --dummy --softservice ' + moduleList.apmFile + ' ' + modPath + '_synth.bsv')

        for wrapper in [wrapper_bsv, log_bsv]:      
          wrapper.write('// These are well-known/required leap modules\n')
          wrapper.write('`include "awb/provides/soft_connections.bsh"\n')
          wrapper.write('`include "awb/provides/soft_services_lib.bsh"\n')
          wrapper.write('`include "awb/provides/soft_services.bsh"\n')
          wrapper.write('`include "awb/provides/soft_services_deps.bsh"\n')
          wrapper.write('`include "awb/provides/soft_connections_debug.bsh"\n')
          wrapper.write('// import non-synthesis public files\n')
          wrapper.write('`include "' + module.name + '_compile.bsv"\n')
          wrapper.write('\n\n')

        log_bsv.write('// First pass to see how large the vectors should be\n')
        log_bsv.write('`define CON_RECV_' + module.name + ' 100\n')
        log_bsv.write('`define CON_SEND_' + module.name + ' 100\n')
        log_bsv.write('`define CON_RECV_MULTI_' + module.name + ' 50\n')
        log_bsv.write('`define CON_SEND_MULTI_' + module.name + ' 50\n')
        log_bsv.write('`define CHAINS_' + module.name + ' 50\n')
        wrapper_bsv.write('// Real build pass.  Include file built dynamically.\n')
        wrapper_bsv.write('`include "' + module.name + '_Wrapper_con_size.bsh"\n')

        for wrapper in [wrapper_bsv, log_bsv]:      
          wrapper.write('(* synthesize *)\n')
          wrapper.write('module [Module] mk_' + module.name + '_Wrapper (SOFT_SERVICES_SYNTHESIS_BOUNDARY#(`CON_RECV_' + module.name + ', `CON_SEND_' + module.name + ', `CON_RECV_MULTI_' + module.name + ', `CON_SEND_MULTI_' + module.name +', `CHAINS_' + module.name +'));\n')
          wrapper.write('  \n')
          # we need to insert the fpga platform here
          # get my parameters 

          wrapper.write('    // instantiate own module\n')
          wrapper.write('    let int_ctx0 <- initializeServiceContext();\n')
          wrapper.write('    match {.int_ctx1, .int_name1} <- runWithContext(int_ctx0, putSynthesisBoundaryID(' + str(module.synthBoundaryUID)  + '));\n');
          wrapper.write('    // By convention, global string ID 0 (the first string) is the module name\n');
          wrapper.write('    match {.int_ctx2, .int_name2} <- runWithContext(int_ctx1, getGlobalStringUID("' + module.name + '"));\n');
          wrapper.write('    match {.int_ctx3, .int_name3} <- runWithContext(int_ctx2, ' + module.synthBoundaryModule + ');\n')
          wrapper.write('    match {.final_ctx, .m_final}  <- runWithContext(int_ctx3, mkSoftConnectionDebugInfo);\n')
          wrapper.write('    let service_ifc <- exposeServiceContext(final_ctx);\n')
          wrapper.write('    interface services = service_ifc;\n')
          wrapper.write('    interface device = m_final;\n')
          wrapper.write('endmodule\n')

        log_bsv.close()

      wrapper_bsv.close()
