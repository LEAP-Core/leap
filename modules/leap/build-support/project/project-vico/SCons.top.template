# -*-Python-*-

import os
import re
import sys
import string
import errno

SetOption('implicit_cache', 1)

defs = {
    'ALL_HW_DIRS'        : '@ALL_HW_DIRS@',
    'APM_FILE'           : '@APM_FILE@',
    'APM_NAME'           : '@APM_NAME@',
    'BDPI_CS'            : '@BDPI_CS@',
    'BSC'                : '@BSC@',
    'BSC_FLAGS_VERILOG'  : '@BSC_FLAGS_VERILOG@',
    'BSC_FLAGS_SIM'      : '@BSC_FLAGS_SIM@',
    'BUILD_DIR'          : '@BUILD_DIR@',
    'CONNECTION_SCRIPT'  : 'leap-connect',
    'COST_TABLE'         : '@COST_TABLE@',
    'FPGA_PART_XILINX'   : '@FPGA_PART_XILINX@',
    'GIVEN_BAS'          : '@GIVEN_BAS@',
    'GIVEN_VHDS'         : '@GIVEN_VHDS@',
    'GIVEN_NGCS'         : '@GIVEN_NGCS@',
    'GIVEN_BMMS'         : '@GIVEN_BMMS@',
    'GIVEN_ELFS'         : '@GIVEN_ELFS@',
    'GIVEN_CS'           : '@GIVEN_CS@',
    'GIVEN_VERILOGS'     : '@GIVEN_VERILOGS@',
    'GIVEN_UCFS'         : '@GIVEN_UCFS@',
    'GIVEN_SDCS'         : '@GIVEN_SDCS@',
    'GEN_BAS'            : '@GEN_BAS@',
    'GEN_VS'             : '@GEN_VS@',
    'GEN_CXXS'           : 'schedule.cxx @GEN_CXXS@',
    'GEN_HS'             : 'schedule.h @GEN_HS@',
    'LDFLAGS'            : '-L /usr/lib64/curses -L /usr/lib/curses',
    'MAKE_ALL_TARGET'    : '@MAKE_ALL_TARGET@',
    'MAP_OPTIONS'        : '@MAP_OPTIONS@',
    'SYNTHESIS_TOOL'     : '@SYNTHESIS_TOOL@',
    'WORKSPACE_ROOT'     : '@MODEL_ROOT@',
    'ROOT_DIR_MODEL'     : '@ROOT_DIR_MODEL@',
    'ROOT_DIR_HW'        : '@ROOT_DIR_HW@',
    'ROOT_DIR_HW_INC'    : '@ROOT_DIR_HW_INC@',
    'ROOT_DIR_SW'        : '@ROOT_DIR_SW@',
    'ROOT_DIR_SW_INC'    : '@ROOT_DIR_SW_INC@',
    'SIMULATED_ISA'      : '@SIMULATED_ISA@',
    'SW_INC_DIRS'        : '@SW_INC_DIRS@',
    'SW_LIBS'            : '@SW_LIBS@',
    'SYNTH_TOP'          : '@SYNTH_TOP@',
    'SYNTH_WRAPPERS'     : '@SYNTH_WRAPPERS@',
    'TMP_BSC_DIR'        : '@TMP_BSC_DIR@',
    'TMP_XILINX_DIR'     : '@TMP_XILINX_DIR@',
    'WORKSPACE_ROOT'     : '@WORKSPACE_ROOT@',
    'SILENT'             : '',
}

# Propagate environment from external state
# rfadeev
env = Environment(ENV = os.environ, DEFS = defs, CC = '/usr/intel/pkgs/gcc/4.3.2/bin/gcc', CXX = '/usr/intel/pkgs/gcc/4.3.2/bin/g++')
env['ENV']['SHELL'] = '/bin/sh'

env['DEFS']['ROOT_DIR_HW_MODEL'] = env['DEFS']['ROOT_DIR_HW'] + '/' + \
                                   env['DEFS']['ROOT_DIR_MODEL'];
env['DEFS']['ROOT_DIR_SW_MODEL'] = env['DEFS']['ROOT_DIR_SW'] + '/' + \
                                   env['DEFS']['ROOT_DIR_MODEL'];

############################################################################
############################################################################
##
## Build the interface files first
##
############################################################################
############################################################################

if os.path.isfile('iface/SConstruct'):
    cmd = 'cd iface; scons -Q'
    if env.GetOption('clean'):
        cmd += ' -c'
    s = os.system(cmd)
    if (s & 0xffff) != 0:
        print 'Aborting due to iface submodel errors'
        sys.exit(1)

############################################################################
############################################################################
##
## Utility functions used in this module and in submodules
##
############################################################################
############################################################################

utility_names = []

##
## clean_split --
##     Split a string into a list using specified separator (default ':'),
##     dropping empty entries.
##
utility_names.append('clean_split')
def clean_split(list, sep=':'):
    return [x for x in list.split(sep) if x != '' ]

##
## rebase_directory --
##     Rebase directory (d) that is a reference relative to the root build
##     directory, returning a result relative to cwd.  cwd must also be
##     relative to the root build directory.
##
utility_names.append('rebase_directory')
def rebase_directory(d, cwd):
    d = clean_split(d, sep='/')
    cwd = clean_split(cwd, sep='/')

    for x in cwd:
        if (len(d) == 0 or d[0] != x):
            d.insert(0, '..')
        else:
            d.pop(0)

    if (len(d) == 0): d = [ '.' ]
    return '/'.join(d)

##
## transform_string_list --
##     Interpret incoming string (str) as a list of substrings separated by (sep).
##     Add (prefix) and (suffix) to each substring and return a modified string.
##
utility_names.append('transform_string_list')
def transform_string_list(str, sep, prefix, suffix):
    if (sep == None):
        sep = ' '
    t = [ prefix + a + suffix for a in clean_split(str, sep) ]
    return string.join(t, sep)

##
## As of Bluespec 2008.11.C the -bdir target is put at the head of the search path
## and the compiler complains about duplicate path entries.
##
## This code removes the local build target from the search path.
##
utility_names.append('bsc_bdir_prune')
def bsc_bdir_prune(str, sep, match):
    t = clean_split(str, sep)
    if (env['DEFS']['BSC_VERSION'] >= 15480):
        try:
            while 1:
                i = t.index(match)
                del t[i]
        except ValueError:
            pass
    return string.join(t, sep)

##
## one_line_cmd --
##     Issue a shell command and return the first line of output
##
def one_line_cmd(cmd):
    p = os.popen(cmd)
    r = p.read().rstrip()
    p.close()
    return r

##
## awb_resolver --
##     Ask awb-resolver for some info.  Return the first line.
##
def awb_resolver(arg):
    return one_line_cmd("awb-resolver " + arg)

############################################################################
############################################################################
##
## SCons configuration.
##
############################################################################
############################################################################

##
## env.Clone() is new as of 0.97.  It used to be called Copy().
##
import SCons.Environment
try:
    SCons.Environment.Environment.Clone
except AttributeError:
    SCons.Environment.Environment.Clone = SCons.Environment.Environment.Copy

############################################################################
############################################################################
##
## Build rules
##
############################################################################
############################################################################

# Bluespec compains about signature mismatches if we use this to avoid
# recompiling across synthesis boundaries.
#TargetSignatures('content')

APM_NAME = env['DEFS']['APM_NAME']
BSC = env['DEFS']['BSC']
BSC_FLAGS_SIM = env['DEFS']['BSC_FLAGS_SIM']
BSC_FLAGS_VERILOG = env['DEFS']['BSC_FLAGS_VERILOG']
LDFLAGS = env['DEFS']['LDFLAGS']
TMP_BSC_DIR = env['DEFS']['TMP_BSC_DIR']
WORKSPACE_ROOT = env['DEFS']['WORKSPACE_ROOT']

##
## DEBUG or OPT build?  User can override the workspace default rule by
## specifying either OPT=1 or DEBUG=1 on the scons command line.
##
if (int(ARGUMENTS.get('OPT', 0))):
    DEBUG = 0
elif (int(ARGUMENTS.get('DEBUG', 0))):
    DEBUG = 1
else:
    DEBUG = int(awb_resolver('-config=debug'))

##
## Enable tracing (software side debugging)?  Always enabled in debug mode.
##
TRACE = int(ARGUMENTS.get('TRACE', 0))
if (DEBUG):
    TRACE = 1

##
## yvbaida:
## In silent mode we reduce output messages to something like '[g++/bsc] target_file'.
## Also we try to reduce as much as possible output to console from tools
##
SILENT = int(ARGUMENTS.get('SILENT', 1))

if (SILENT):
    CC = '@echo [gcc] $SOURCE; ' + env['CC']
    CXX = '@echo [g++] $SOURCE; ' + env['CXX']
    BSC = '@echo [bsc] $SOURCE; ' + env['DEFS']['BSC']
    env['DEFS']['SILENT'] = 1
    XILINX_INTSTYLE = '-intstyle xflow ' # Integration style for Xilinx tools
    ECHO_PREFIX = '@' # Prefix to hide some commands
else:
    CC = env['CC']
    CXX = env['CXX']
    BSC = 'time ' + env['DEFS']['BSC']
    XILINX_INTSTYLE = '-intstyle xflow ' # Integration style for Xilinx tools
    ECHO_PREFIX = '' # Prefix to hide some commands 

env['CC'] = CC
env['CXX'] = CXX
env['DEFS']['BSC'] = BSC

##
## Override Xilinx COST_TABLE with command line
##
env['DEFS']['COST_TABLE'] = ARGUMENTS.get('COST_TABLE', env['DEFS']['COST_TABLE'])

##
## Build events into model?
##
enable_events = int(ARGUMENTS.get('EVENTS', -1))
if (enable_events == -1):
    enable_events = int(awb_resolver('-config=events'))

if (enable_events == 0):
    bsc_events_flag = '-D HASIM_EVENTS_ENABLED=False'
    cpp_events_flag = ''
else:
    bsc_events_flag = '-D HASIM_EVENTS_ENABLED=True'
    cpp_events_flag = '-DHASIM_EVENTS_ENABLED'

BSC_FLAGS_VERILOG += ' ' + bsc_events_flag
env['DEFS']['BSC_FLAGS_VERILOG'] = BSC_FLAGS_VERILOG

BSC_FLAGS_SIM += ' ' + bsc_events_flag
env['DEFS']['BSC_FLAGS_SIM'] = BSC_FLAGS_SIM


ROOT_WRAPPER_SYNTH_ID = 'mk_' + env['DEFS']['ROOT_DIR_MODEL'] + '_Wrapper'

if env['DEFS']['GIVEN_CS'] != '':
    SW_EXE_OR_TARGET = env['DEFS']['ROOT_DIR_SW'] + '/obj/' + APM_NAME + '_sw.so'
    SW_EXE = [SW_EXE_OR_TARGET]
else:
    SW_EXE_OR_TARGET = '$TARGET'
    SW_EXE = []

# What is the Bluespec compiler version?
bsc_version = 0

bsc_ostream = os.popen('bsc -verbose')
ver_regexp = re.compile('^Bluespec Compiler, version.*\(build ([0-9]+),')
for ln in bsc_ostream.readlines():
    m = ver_regexp.match(ln)
    if (m):
        bsc_version = int(m.group(1))
bsc_ostream.close()

if bsc_version == 0:
    print "Failed to get Bluespec compiler version"
    sys.exit(1)

env['DEFS']['BSC_VERSION'] = bsc_version

############################################################################
##
## Rules for HW subdirectory.  These are shared by all targets.
##
############################################################################
env['DEFS']['CWD_REL'] = env['DEFS']['ROOT_DIR_HW_MODEL']
env['DEFS']['BSC_FLAGS'] = env['DEFS']['BSC_FLAGS_VERILOG']
Export('env ' + " ".join(utility_names))
wrapper_v = SConscript([env['DEFS']['ROOT_DIR_HW_MODEL'] + '/SConscript'])

BuildDir(TMP_BSC_DIR, '.', duplicate=0)
env['ENV']['BUILD_DIR'] = env['DEFS']['BUILD_DIR']  # need to set the builddir for synplify

############################################################################
##
## Rules for building a Bluesim EXE.
##
############################################################################

# FIXME [yvbaida] Workaround for Bluespec2011.04beta2. Left only '-sim' key on link stage.
BSC_FLAGS_SIM_LINK = re.sub("-verilog", "", BSC_FLAGS_SIM);
 
bsc_sim_command = BSC + ' ' + BSC_FLAGS_SIM_LINK + ' ' + LDFLAGS + ' -o $TARGET'

if (env['DEFS']['BSC_VERSION'] >= 13013):
    # 2008.01.A compiler allows us to pass C++ arguments.
    if (DEBUG):
        bsc_sim_command += ' -Xc++ -O0'
    else:
        bsc_sim_command += ' -Xc++ -O1'

bsc_sim_command += \
    ' -sim -e ' + ROOT_WRAPPER_SYNTH_ID + ' -simdir ' + \
    TMP_BSC_DIR + ' ' + env['DEFS']['GEN_BAS'] + ' ' + env['DEFS']['GIVEN_BAS'] + \
    ' ' + env['DEFS']['BDPI_CS']

sbin = env.Command(
    TMP_BSC_DIR + '/' + APM_NAME + '_hw.exe',
    wrapper_v + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['BDPI_CS'], sep=' '),
    bsc_sim_command)

if env.GetOption('clean'):
    os.system('rm -rf .bsc')

#
# The final step must leave a few well known names:
#   APM_NAME must be the software side, if there is one.  If there isn't, then
#   it must be the Bluesim image.
#
exe = env.Command(
    APM_NAME + '_hw.exe',
    sbin + SW_EXE,
    [ '@ln -fs ${SOURCE} ${TARGET}',
      '@ln -fs ${SOURCE}.so ${TARGET}.so',
      '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.vexe'),
      Delete(APM_NAME + '_hw.errinfo') ])

env.Alias('exe', exe)

############################################################################
##
## Rules for building a Verilog simulation vexe
##
############################################################################

# aefimov: Bluespec expects top module has CLK and RST_N input ports. Braindead again!
# So model wrapper is modified to have these ports, although they are not used
vexe_modified_wrapper = '';
vexe_modified_wrapper_command = '';
VEXE_GEN_VS = [];
for x in clean_split(env['DEFS']['GEN_VS'], sep = ' '):
    if (re.match('.*mk_model_Wrapper.v$', x) != None):
        vexe_modified_wrapper = x + '.modified.v';
        vexe_modified_wrapper_command = "@sed -e 's/module mk_model_Wrapper;/module mk_model_Wrapper(CLK, RST_N);\\n input CLK;\\n input RST_N;/' " + x + ' > ' + x + '.modified.v'
        VEXE_GEN_VS.insert(0, vexe_modified_wrapper);
    else:
        VEXE_GEN_VS.insert(0, x);

vpatch = env.Command(
    vexe_modified_wrapper,
    clean_split(env['DEFS']['GEN_VS'], sep = ' '),
    [ vexe_modified_wrapper_command ])

# aefimov: remove '-remove-dollar' flag, BSC link fails otherwise
BSC_FLAGS_VERILOG_LINK = BSC_FLAGS_VERILOG.replace('-remove-dollar', ' ')

vexe_gen_command = \
    BSC + ' ' + BSC_FLAGS_VERILOG_LINK + ' -vdir ' + env['DEFS']['ROOT_DIR_HW'] + '/' + env['DEFS']['ROOT_DIR_MODEL'] + '/' + env['DEFS']['TMP_BSC_DIR'] + \
    ' -o $TARGET -verilog -e ' + ROOT_WRAPPER_SYNTH_ID + \
    ' $SOURCES ' + env['DEFS']['GIVEN_BAS'] + ' | tee vexe_vcs_build.log';

# aefimov: VCS creates hard-links to .so libraries, but we need executable w/o hard-links..
# To do it I run BSC which invokes normal VCS build,
# I do it to perform compilation and to get compilation log,
# then I grep and patch link command line,
# and execute it to build final executable
vbin1 = env.Command(
    TMP_BSC_DIR + '/' + APM_NAME + '_tmp_hw.vexe',
    VEXE_GEN_VS + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VHDS'], sep = ' ') + clean_split(env['DEFS']['BDPI_CS'], sep=' '),
    [ vexe_gen_command,
      Delete('directc.sft') ])

vbin2 = env.Command(
    TMP_BSC_DIR + '/' + APM_NAME + '_hw.vexe',
    TMP_BSC_DIR + '/' + APM_NAME + '_tmp_hw.vexe',
    [
      ECHO_PREFIX + "cat vexe_vcs_build.log | " +
        "grep -E 'g\\+\\+.+" + APM_NAME + "_tmp_hw\\.vexe' | " +
        "sed -e 's/" + APM_NAME + "_tmp_hw.vexe/" + APM_NAME + "_hw.vexe/' | " +
        "sed -r -e 's/([^ ]*)\\/lib(\\w+)\\.so\\s/-L \\1 -l \\2 /g' | " +
        "sed -r -e 's/[^ ]*\\/directc_mk_model_Wrapper\\.so/directc_mk_model_Wrapper\.so/' " +
        "> vexe_vcs_link; " +
      "chmod +x vexe_vcs_link; " +
      "cd csrc; " +
      "test -f ../directc_mk_model_Wrapper.so && ln -fs ../directc_mk_model_Wrapper.so; " +
      "../vexe_vcs_link; " +
      "cd ..; " +
      "cp -R .bsc/" + APM_NAME + "_tmp_hw.vexe.daidir .bsc/" + APM_NAME + "_hw.vexe.daidir "
    ])

# aefimov: vcd file generation disabled
# I saw 120GB VCD file for 40K model cycles executed
vexe = env.Command(
    APM_NAME + '_hw.vexe',
    vpatch + vbin1 + vbin2 + SW_EXE,
    [ '@echo "#!/bin/sh" > $TARGET',
#     '@echo "./$SOURCE +bscvcd \$*" >> $TARGET',
      '@echo "' + TMP_BSC_DIR + '/' + APM_NAME + '_hw.vexe \$*" >> $TARGET',
      '@chmod a+x $TARGET',
      '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.exe'),
      Delete(APM_NAME + '_hw.exe.so'),
      Delete(APM_NAME + '_hw.errinfo') ])

env.Alias('vexe', vexe)

############################################################################
##
## Rules for building a Xilinx bit image
##
############################################################################

TMP_XILINX_DIR = env['DEFS']['TMP_XILINX_DIR']
XILINX_APM_NAME = TMP_XILINX_DIR + '/' + APM_NAME

SYNTH_TOP = env['DEFS']['SYNTH_TOP']
XILINX_SYNTH_TOP = TMP_XILINX_DIR + '/' + SYNTH_TOP

FPGA_PART_XILINX = env['DEFS']['FPGA_PART_XILINX']

# aefimov: create filter file to silence the most annoying warnings
XFilterFile = open('config/' + APM_NAME + '.filter','w')
XFilterFile.write('<filters xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="filter.xsd">')
if (SILENT):
    XFilterFile.write('<filter task="map" file="PhysDesignRules" num="367" type="warning"></filter>')
    XFilterFile.write('<filter task="par" file="Par" num="288" type="warning"></filter>')
    XFilterFile.write('<filter task="bitgen" file="PhysDesignRules" num="367" type="warning"></filter>')
XFilterFile.write('</filters>')
XFilterFile.close();

wrapper_builds = []

# Concatenate SDC files
if len(env['DEFS']['GIVEN_SDCS']) != 0:
    synplify_sdc = env.Command(
        XILINX_APM_NAME + '.sdc',
        clean_split(env['DEFS']['GIVEN_SDCS'], sep = ' '),
        ECHO_PREFIX + 'cat $SOURCES > $TARGET')
else:
    synplify_sdc = env.Command(
        XILINX_APM_NAME + '.sdc',
        clean_split(env['DEFS']['GIVEN_SDCS'], sep = ' '),
        ECHO_PREFIX + 'touch $TARGET')

if (re.match("^synplify_(pro|premier)$", env['DEFS']['SYNTHESIS_TOOL'])):
    #
    # Parallel build. Each synthesis boundary is independent.
    #
    for wrapper in env['DEFS']['SYNTH_WRAPPERS'].split():
        newFile = open('config/' + wrapper + '.modified.synplify.prj','w')
        oldFile = open('config/' + wrapper + '.synplify.prj','r')

        newFile.write(oldFile.read())
        # we must tweak files of the internal module list to prevent the insertion of iobuffers
        newFile.write('set_option -disable_io_insertion 1\n')
 
        newFile.close()
        oldFile.close()

        w = env.Command(
            TMP_XILINX_DIR + '/' + wrapper + '.edf',
            wrapper_v + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + ['config/' + wrapper + '.modified.synplify.prj'],
            [ Delete(XILINX_APM_NAME + '.srr'),
              '@mkdir -p ' + TMP_XILINX_DIR + '/' + wrapper,
              env['DEFS']['SYNTHESIS_TOOL'] + ' -batch -license_wait config/' + wrapper + '.modified.synplify.prj >& ' + TMP_XILINX_DIR + '/' + wrapper + '.log',
              '@cp ' + TMP_XILINX_DIR + '/' + wrapper + '/' + wrapper + '.edf ' + TMP_XILINX_DIR + '/' + wrapper +'.edf',
              '@echo ' + env['DEFS']['SYNTHESIS_TOOL'] + ' ' + wrapper + ' build complete.' ])

        wrapper_builds += w
        Clean(w,  TMP_XILINX_DIR + '/' + wrapper + '/' + wrapper + '.srr')

    top_netlist = env.Command(
        XILINX_SYNTH_TOP + '.edf',
        wrapper_v + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + ['config/' + SYNTH_TOP + '.synplify.prj'] + synplify_sdc,
        [ Delete(XILINX_SYNTH_TOP + '.srr'),
          '@mkdir -p ' + XILINX_SYNTH_TOP,
          env['DEFS']['SYNTHESIS_TOOL'] + ' -batch -license_wait config/' + SYNTH_TOP + '.synplify.prj >& ' + XILINX_SYNTH_TOP + '.log',
          '@cp ' + XILINX_SYNTH_TOP + '/' + SYNTH_TOP + '.edf ' + XILINX_SYNTH_TOP + '.edf',
          '@echo ' + env['DEFS']['SYNTHESIS_TOOL'] + ' ' + SYNTH_TOP + ' build complete.' ])

    Clean(top_netlist,  XILINX_SYNTH_TOP + '/' + SYNTH_TOP + '.srr')

else:
    #
    # Parallel build. Each synthesis boundary is independent.
    #
    for wrapper in env['DEFS']['SYNTH_WRAPPERS'].split():
        # we must tweak the xst files of the internal module list
        # to prevent the insertion of iobuffers
        newXSTFile = open('config/' + wrapper + '.modified.xst','w')
        oldXSTFile = open('config/' + wrapper + '.xst','r')

        # Delete reference to .xcf file if not top module
        for line in oldXSTFile:
            if (re.match("^-uc.+", line) == None):
                newXSTFile.write(line)

        newXSTFile.write('-iobuf no\n')
        newXSTFile.close()
        oldXSTFile.close()

        w = env.Command(
            TMP_XILINX_DIR + '/' + wrapper + '.ngc',
            wrapper_v + clean_split(env['DEFS']['GIVEN_VHDS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_NGCS'], sep = ' ') + ['config/' + wrapper + '.xst'],
            [ Delete(TMP_XILINX_DIR + '/' + wrapper + '.srp'),
              Delete(TMP_XILINX_DIR + '/' + wrapper + '_xst.xrpt'),
              ECHO_PREFIX + 'xst -intstyle silent -ifn config/' + wrapper + '.modified.xst -ofn ' + TMP_XILINX_DIR + '/' + wrapper + '.srp -filter config/' + APM_NAME + '.filter',
              '@echo xst ' + wrapper + ' build complete.' ])

        wrapper_builds += w
        Clean(w,  TMP_XILINX_DIR + '/' + wrapper + '.srp')

    top_netlist = env.Command(
        XILINX_SYNTH_TOP + '.ngc',
        wrapper_v + clean_split(env['DEFS']['GIVEN_VHDS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_VERILOGS'], sep = ' ') + clean_split(env['DEFS']['GIVEN_NGCS'], sep = ' ') + ['config/' + SYNTH_TOP + '.xst'],
        [ Delete(XILINX_SYNTH_TOP + '.srp'),
          Delete(XILINX_SYNTH_TOP + '_xst.xrpt'),
          ECHO_PREFIX + 'xst -intstyle silent -ifn config/' + SYNTH_TOP + '.xst -ofn ' + XILINX_SYNTH_TOP + '.srp -filter config/' + APM_NAME + '.filter',
          '@echo xst ' + SYNTH_TOP + ' build complete.' ])

    Clean(top_netlist,  XILINX_SYNTH_TOP + '.srp')

# Concatenate UCF files
xilinx_ucf = env.Command(
    XILINX_APM_NAME + '.ucf',
    clean_split(env['DEFS']['GIVEN_UCFS'], sep = ' '),
    ECHO_PREFIX + 'cat $SOURCES > $TARGET')


if len(env['DEFS']['GIVEN_BMMS']) != 0:
    xilinx_bmm = env.Command(
        XILINX_APM_NAME + '.bmm',
        clean_split(env['DEFS']['GIVEN_BMMS'], sep = ' '),
        ECHO_PREFIX + 'cat $SOURCES > $TARGET')
    #./ works around crappy xilinx parser
    bmm = ' -bm ./' + XILINX_APM_NAME + '.bmm'
else:
    xilinx_bmm = ''
    bmm = ''

xilinx_ngd = env.Command(
    XILINX_APM_NAME + '.ngd',
    top_netlist + xilinx_ucf + xilinx_bmm,
    [ Delete(XILINX_APM_NAME + '.bld'),
      Delete(XILINX_APM_NAME + '_ngdbuild.xrpt'),
      # Xilinx project files are created automatically by Xilinx tools, but not
      # needed for command line tools.  The project files may be corrupt due
      # to parallel invocation of xst.  Until we figure out how to move them
      # or guarantee their safety, just delete them.
      Delete('xlnx_auto_0.ise'),
      Delete('xlnx_auto_0_xdb'),
      '@echo',
      '@echo "****** NGD Build ******"',
      '@echo',
      ECHO_PREFIX + 'ngdbuild ' + XILINX_INTSTYLE + '-aul -aut -p ' + FPGA_PART_XILINX + ' -sd ' + env['DEFS']['ROOT_DIR_HW_MODEL'] + ' -uc ' + XILINX_APM_NAME + '.ucf ' + bmm + ' -filter config/' + APM_NAME + '.filter $SOURCE $TARGET',
      Move(TMP_XILINX_DIR + '/netlist.lst', 'netlist.lst') ])

Depends(xilinx_ngd, wrapper_builds)

Clean(xilinx_ngd, TMP_XILINX_DIR + '/netlist.lst')

# Alias for everything up to map...
env.Alias('xst', xilinx_ngd + SW_EXE)

#
# Use a cached post par ncd to guide map and par?  This is off by default since
# the smart guide option can make place & route fail when it otherwise would have
# worked.  It doesn't always improve run time, either.  To turn on smart guide
# either define the environment variable USE_SMARTGUIDE or set
# USE_SMARTGUIDE on the scons command line to a non-zero value.
#

#
#  In case of simultaneousely start of some model builds  there sometimes rises conflict on '/var/xilinx_ncd creation: 'if exist' checking  before mkdir call not enough
#  Exception handling inspired by Michael Adler
#
smartguide_cache_dir = env['DEFS']['WORKSPACE_ROOT'] + '/var/xilinx_ncd'
try:
    os.makedirs(smartguide_cache_dir)
except OSError, e:
    if e.errno == errno.EEXIST: pass

smartguide_cache_file = APM_NAME + '_par.ncd'

if ((int(ARGUMENTS.get('USE_SMARTGUIDE', 0)) or env['ENV'].has_key('USE_SMARTGUIDE')) and
    (FindFile(APM_NAME + '_par.ncd', [smartguide_cache_dir]) != None)):
    smartguide = ' -smartguide ' +  smartguide_cache_dir + '/' + smartguide_cache_file
else:
    smartguide = ''

# Map
xilinx_map = env.Command(
    [ XILINX_APM_NAME + '_map.ncd', XILINX_APM_NAME + '.pcf' ],
    xilinx_ngd,
    [ Delete(XILINX_APM_NAME + '_map.map'),
      Delete(XILINX_APM_NAME + '_map.mrp'),
      Delete(XILINX_APM_NAME + '_map.ncd'),
      Delete(XILINX_APM_NAME + '_map.ngm'),
      Delete(XILINX_APM_NAME + '_map.psr'),
      '@echo',
      '@echo "****** Map ******"',
      '@echo',
      ECHO_PREFIX + 'map ' + XILINX_INTSTYLE + '-mt 2 -timing ' + smartguide + ' -t ' + env['DEFS']['COST_TABLE'] + ' ' +  env['DEFS']['MAP_OPTIONS'] + ' -logic_opt on -ol high -retiming on -pr b -c 100 -p ' + FPGA_PART_XILINX + ' -filter config/' + APM_NAME + '.filter' + ' -o $TARGET $SOURCE ' + XILINX_APM_NAME + '.pcf' ])

Clean(xilinx_map, TMP_XILINX_DIR + '/xilinx_device_details.xml')

# Place and route
xilinx_par = env.Command(
    XILINX_APM_NAME + '_par.ncd',
    xilinx_map,
    [ Delete(XILINX_APM_NAME + '_par.pad'),
      Delete(XILINX_APM_NAME + '_par.par'),
      Delete(XILINX_APM_NAME + '_par.ptwx'),
      Delete(XILINX_APM_NAME + '_par.unroutes'),
      Delete(XILINX_APM_NAME + '_par.xpi'),
      Delete(XILINX_APM_NAME + '_par_pad.csv'),
      Delete(XILINX_APM_NAME + '_par_pad.txt'),
      '@echo',
      '@echo "****** Place & Route ******"',
      '@echo',
      ECHO_PREFIX + 'par ' + XILINX_INTSTYLE + '-mt 4 -w -ol high ' + smartguide + ' ' + XILINX_APM_NAME + '_map.ncd -filter config/' + APM_NAME + '.filter $TARGET ' + XILINX_APM_NAME + '.pcf',
      Copy(smartguide_cache_dir + '/' + smartguide_cache_file, '$TARGET') ])

# Generate the FPGA timing report -- this report isn't built by default.
# Use the "timing" target to generate it
xilinx_trce = env.Command(
    XILINX_APM_NAME + '_par.twr',
    [ xilinx_par, XILINX_APM_NAME + '.pcf' ],
    'trce -e 100 $SOURCES -o $TARGET')

if len(env['DEFS']['GIVEN_ELFS']) != 0:
    elf = ' -bd ' + str.join(' -bd ',clean_split(env['DEFS']['GIVEN_ELFS'], sep = ' '))
else:
    elf = ''

# Generate the FPGA image
xilinx_bit = env.Command(
    XILINX_APM_NAME + '_par.bit',
    [ 'config/' + APM_NAME + '.ut', xilinx_par],
    [ Delete('config/signature.sh'),
      '@echo',
      '@echo "****** Bit File Generation ******"',
      '@echo',
      ECHO_PREFIX + 'bitgen ' + XILINX_INTSTYLE + elf + ' -f $SOURCES $TARGET ' + XILINX_APM_NAME + '.pcf -filter config/' + APM_NAME + '.filter' ])

Depends(xilinx_bit, clean_split(env['DEFS']['GIVEN_ELFS'], sep = ' '));

# Generate the signature for the FPGA image
signature = env.Command(
    'config/signature.sh',
    xilinx_bit,
    [ '@echo \'#!/bin/sh\' > $TARGET',
      '@echo signature=\\"' + APM_NAME + '-`md5sum $SOURCE | sed \'s/ .*//\'`\\" >> $TARGET' ])

#
# The final step must leave a few files in well-known locations since they are
# used by the run scripts.  APM_NAME is the software side, if there is one.
#
loader = env.Command(
    APM_NAME + '_hw.errinfo',
    signature + SW_EXE + xilinx_trce,
    [ '@ln -fs ' + SW_EXE_OR_TARGET + ' ' + APM_NAME,
      Delete(APM_NAME + '_hw.exe'),
      Delete(APM_NAME + '_hw.exe.so'),
      Delete(APM_NAME + '_hw.vexe'),
      '@echo',
      '@echo "****** Post-Place & Route ******"',
      '@echo',
      '@' + awb_resolver('tools/scripts/leap-xilinx-summary') + ' ' +
          XILINX_APM_NAME + '_map.map ' +
          XILINX_APM_NAME + '_par.par ' +
          APM_NAME + '_hw.errinfo' ])

env.Alias('bit', loader)

##
## Clean up a few extra files not described in the build rules
##
if env.GetOption('clean'):
    os.system('cd ' + TMP_XILINX_DIR + '; rm -f ' + APM_NAME + '*')
    os.system('rm -f APM_NAME')

############################################################################
##
## Rules for building the software side.  Invoke scripts in subdirectories
## to define the objects needing to be built.  The final link is defined
## here.
##
############################################################################

def host_defs():
    hostos = one_line_cmd('uname -s')
    hostmachine = one_line_cmd('uname -m')

    if (hostos == 'FreeBSD'):
        hflags = '-DHOST_FREEBSD'
    else:
        hflags = '-DHOST_LINUX'
        if (hostmachine == 'ia64'):
            hflags += ' -DHOST_LINUX_IA64'
        else:
            hflags += ' -DHOST_LINUX_X86'

    return hflags

if SW_EXE != []:
    inc_paths = clean_split(env['DEFS']['SW_INC_DIRS'], sep = ' ')
    libs = clean_split(env['DEFS']['SW_LIBS'], sep = ' ')
    cc_flags = host_defs()
    cc_flags += ' -fPIC ' + cpp_events_flag
    #aefimov: adding ViCo timings profiling
    cc_flags += ' -DVICO_TIMINGS'
    if (DEBUG):
        cc_flags += ' -DASIM_ENABLE_ASSERTIONS'
    if (TRACE):
        cc_flags += ' -DASIM_ENABLE_TRACE'
    cc_flags += ' -DAPM_NAME=\\"' + APM_NAME + '\\"'

    if (DEBUG):
        copt_flags = '-ggdb3 '
    else:
        copt_flags = '-g -O2 '

    # CPPPATH defines both gcc include path and dependence path for
    # SCons.  The '#' forces paths to be relative to the root of the build.
    sw_env = env.Clone(CCFLAGS = copt_flags + cc_flags,
                       LINKFLAGS = copt_flags + ' -shared',
                       CPPPATH = [ '#/' + env['DEFS']['ROOT_DIR_SW_INC'],
                                   '#/' + env['DEFS']['ROOT_DIR_HW_MODEL'],
                                   '#/iface/build/include',
                                   '.' ] + inc_paths)

    sw_env['DEFS']['CWD_REL'] = sw_env['DEFS']['ROOT_DIR_SW_MODEL']

    Export('sw_env ' + " ".join(utility_names))
    sw_build_dir = sw_env['DEFS']['ROOT_DIR_SW'] + '/obj'
    sw_objects = SConscript([env['DEFS']['ROOT_DIR_SW_MODEL'] + '/SConscript'],
                            build_dir = sw_build_dir,
                            duplicate = 0)

    sw_libpath = [ '.' ]
    sw_link_libs = [ 'pthread' ]

    # aefimov: VIP software models may require dl & z, so include them always
    sw_link_libs += [ 'dl' ]
    sw_link_libs += [ 'z' ]
    sw_link_libs += [ 'vico' ]

    sw_link_tgt = SW_EXE

    ##
    ## Put libs on the list of objects twice as a hack to work around the
    ## inability to specify the order of %library declarations across separate
    ## awb files.  Unix ld only searches libraries in command line order.
    ##

    # aefimov: we are goint to build models on one PC and run on another,
    # so we need to link all .so libraries without paths to them,
    # we will provide paths later by setting LD_LIBRARY_PATH
    # To do it I remove paths from all .so libs, create links to each .so
    # in build folder, and run link
    lib_paths = [];
    lib_names = [];
    for x in libs[:]:
        if (re.match(r"^.+\.so$", x) != None):
            y = 'ln -sf ' + x;
            lib_paths.insert(0, y);
            x = re.sub(r"^.+/(\w+)\.so$", r"\1.so", x);
            lib_names.insert(0, x);
        else:
            lib_names.insert(0, x);

    for x in lib_paths:
        os.system(x);

    sw_exe = sw_env.Program(
        sw_link_tgt,
        sw_objects + lib_names + lib_names,
        LIBPATH=sw_libpath,
        LIBS=sw_link_libs)

############################################################################
############################################################################

##
## Set a default target
##
if (env['DEFS']['MAKE_ALL_TARGET'] != ''):
    Default(env['DEFS']['MAKE_ALL_TARGET'])
else:
    Default(exe)

