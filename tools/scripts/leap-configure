#!/usr/bin/env perl
# -*- perl -*-

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  Martha Mercaldi
#

use File::Basename;
use File::Spec;
use Getopt::Long;
use IO::File;

use Asim;
use AsimShell;

use Leap;

use Data::Dumper;

use warnings;
use strict;

#
# Turn on warnings
#
$^W = 1;

#
# Initialize asim
#
Asim::init()
    || die("Unable to initialize Asim::\n");

##
## Dynamic param arrays are initialized by make_bsvfiles() and used later
##
my %dynamic_params;
my %all_params;


############################################################
# command line handling

my $status;

my $help = 0;
my $options = 0;
my $debug = 0;

# only one of the following command flags should be set

my $configure = 0;
my $nuke = 0;
my $setup = 0;
my $build = 0;
my $run = 0;
my $pythonize = 0;

# command options

my $optlist = "leap-configure";

my $model =     Asim::get_option($optlist, "MODEL",     undef);
my $benchmark = Asim::get_option($optlist, "BENCHMARK", undef);

my $builddir =  Asim::get_option($optlist, "BUILDDIR",  undef);
my $buildopt =  Asim::get_option($optlist, "BUILDOPT",  "all");
my $rundir =    Asim::get_option($optlist, "RUNDIR",    undef);
my $runopt =    Asim::get_option($optlist, "RUNOPT",    "");

my $private =   Asim::get_option($optlist, "PRIVATE",   1);
my $public =    Asim::get_option($optlist, "PUBLIC",    1);
my $relative =  Asim::get_option($optlist, "RELATIVE",  0);
my $silent =    Asim::get_option($optlist, "SILENT",    0);


$status = GetOptions( "private!"    => \$private,
                      "public!"     => \$public,
                      "relative!"   => \$relative,
                      "silent!"     => \$silent,
                      "configure"   => \$configure,
                      "nuke"        => \$nuke,
                      "setup"       => \$setup,
                      "build"       => \$build,
                      "pythonize"   => \$pythonize,
                      "run"         => \$run,
		      "model=s"     => \$model,
		      "builddir=s"  => \$builddir,
		      "benchmark=s" => \$benchmark,
		      "rundir=s"    => \$rundir,
                      "buildopt:s"  => \$buildopt,
		      "runopt:s"    => \$runopt,
                      "help"        => \$help,
                      "options"     => \$options,
                      "debug"       => \$debug
		      );
		      
my $prog = basename($0);


if (!$status) {
    Leap::Util::WARN_AND_DIE("Illegal argument, try '$prog --help'");
    exit 0;
}

my $num_commands = $configure + $nuke + $build + $setup + $run + $pythonize;

if ($num_commands > 1) {
    print STDERR "$prog: Must supply exactly one command. See $prog --help \n";
    exit 0;
}

if ($num_commands == 1) {
#   Enable the next line when Model.pm is updated to use the new command format
#   print STDERR "prog: Using deprecated switch-based commands. See $prog --help\n";

#   Enable the next line when everyone should be using the new command format
#   exit 0;
}

$num_commands += $help + $options;

if ($num_commands == 0 && $#ARGV != -1) {
    my $command = shift @ARGV;

    if ($command eq "nuke") {
        $nuke = 1;
        $num_commands = 1;
    } elsif ($command eq "configure" ) {
        $configure = 1;
        $num_commands = 1;
    } elsif ($command eq "build" ) {
        $build = 1;
        $num_commands = 1;
    } elsif ($command eq "setup" ) {
        $setup = 1;
        $num_commands = 1;
    } elsif ($command eq "run" ) {
        $run = 1;
        $num_commands = 1;
    } elsif ($command eq "pythonize" ) {
        $pythonize = 1;
        $num_commands = 1;
    } elsif ($command eq "help" ) {
        $help = 1;
        $num_commands = 1;
    } elsif ($command eq "options" ) {
        $options = 1;
        $num_commands = 1;
    } else {
        print STDERR "$prog: Illegal command: $command.  See $prog --help\n";
        exit 0;
    }
}

if ($help) {
    system "perldoc $0";
    exit 0;
}

if ($options) {
    $Asim::default_workspace->dump_options();
    exit 0;
}

if ($num_commands == 0) {
    print STDERR "$prog: A command must be provided. See $prog --help\n";
    exit 0;
}




#
# Alternative (deprecated) method of specifying model name
#
if (!defined($model)) {
  $model = $ARGV[0];
}


############################################################
# main body of script

select STDERR; $| = 1;
select STDOUT; $| = 1;

print "Opening... $model\n" if $debug;
    

if ($configure) {
    print "Configuring build tree for $model . . . \n";
    $status = configure_build_tree($model);
} elsif ($nuke) {
    print "Nuking build tree. . . \n";
    $status = delete_build_tree($model);
} elsif ($build) {
    print "Compiling build tree. . . \n";
    $status = build_build_tree($model);
} elsif ($setup) {
    print "Setting up benchmark. . . \n";
    $status = setup_benchmark($model, $benchmark);
} elsif ($run) {
    print "Running model. . . \n";
    $status = run_model($model, $benchmark);
} elsif($pythonize) {
    $status = pythonize_model($model);
}

if ($status) {
    if(!$silent) {
	print "Done\n";
    }
    exit(0);
}
else {
    print "leap-configure exiting with errors\n";
    exit(1);
}

############################################################
# run_model
sub run_model {
    my $modelfile = shift;
    my $benchmarkfile = shift;

    my $sys_status;

    my $model = Asim::Model->new($modelfile);
    if (!defined($model)) {
      print "Failed to open model file.\n";
      return 0;
    }

    if (!defined($benchmarkfile)) {
      $benchmarkfile = $model->default_benchmark();

      if (!defined($benchmarkfile)) {      
        print "Undefined Benchmark for running.\n";
        return 0;
      }
    }

    if (!defined($rundir)) {
      $rundir = $model->run_dir($benchmarkfile);
    }

    my $exe = Leap::Util::path_append($rundir, "run $runopt");

    $sys_status = system("cd $rundir; $exe");

    return ($sys_status == 0);
}

############################################################
# generate a python representation of the build tree
sub pythonize_model {
    my $modelfile = shift;

    my $sys_status;

    my $model = Asim::Model->new($modelfile);
    if (!defined($model)) {
      print "Failed to open model file.\n";
      return 0;
    }


    if (defined(&Asim::Model::embed_submodels)) {
	$model->embed_submodels();
    } 

    # (0) validate model structure                                                                                                                        
    validate_model($model) || return 0;

    my $root = $model->modelroot();

    my $pythonRepresentation = __pythonize_model($root);
    print "[" . $pythonRepresentation . "]";
    return 1;
}

sub __pythonize_model {
    my $module = shift;

    my $pythonRepresentation = Leap::Build::pythonize_module($module);

    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
       $pythonRepresentation =  $pythonRepresentation  . __pythonize_model($child);
    }

    return $pythonRepresentation;
}

############################################################
# setup_benchmark
sub setup_benchmark {
    my $modelfile = shift;
    my $benchmarkfile = shift;

    my $sys_status;

    my $model = Asim::Model->new($modelfile);
    if (!defined($model)) {
      print "Failed to open model file.\n";
      return 0;
    }

    if (!defined($benchmarkfile)) {
      $benchmarkfile = $model->default_benchmark();

      if (!defined($benchmarkfile)) {      
        print "Undefined Benchmark for running.\n";
        return 0;
      }
    }

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    if (!defined($rundir)) {
      $rundir = $model->run_dir($benchmarkfile);
    }

    #Actually create rundir

    my $benchmark = Asim::Benchmark->new($benchmarkfile);
    if (! defined($benchmark)) {
        print "Failed to open benchmark file $benchmarkfile";
        return 0;
    }

    my $setup_command = $benchmark->setup_command();
    my $setup_args = $benchmark->setup_args();
    my $srcdir = dirname($setup_command);

    # Create the run dir
    $sys_status = system("rm -rf $rundir");
    if ($sys_status) {
      print "Could not remove rundir ($rundir)\n";
      return 0;
    }

    $sys_status = system("mkdir -p ${rundir}/config");
    if ($sys_status) {
      print "Could not create config in rundir ($rundir)\n";
      return 0;
    }

    my $feed_arg = '';
    if (${benchmark}->feeder() ne '') {
        $feed_arg = "--feeder " . ${benchmark}->feeder();
    }

    my $relmodeldir = "${builddir}";
    $relmodeldir = File::Spec->abs2rel($relmodeldir, $rundir);

    # Add a .bsc link to the model directory.  This is needed for Bluesim.
    system("cd ${rundir}; ln -fs ${relmodeldir}/.bsc .bsc");

    my $model_name = Leap::Build::get_model_name($model);

    ##
    ## Add the runtime initialization stub
    ##
    ##   The output of this file must be simple so it can be parsed in multiple
    ##   scripting languages.  For /bin/sh it should just be loadable.  For
    ##   Perl or Python it should be just a series of assignments.
    ##
    open(STUB, "> ${rundir}/config/env.sh") or Leap::Util::WARN_AND_DIE("Failed to open ${rundir}/config/env.sh");
    print STUB "#!/bin/sh\n";
    print STUB "#\n";
    print STUB "# Generated automatically by leap-configure\n";
    print STUB "#\n\n";
    print STUB "modelDir=\"${relmodeldir}\"\n";
    print STUB "model=\"${model_name}\"\n";
    print STUB "workload=\"" . basename($rundir) . "\"\n";
    print STUB "feeder=\"" . ${benchmark}->feeder() . "\"\n";
    print STUB "genFlags=\"" . ${benchmark}->general_flags() . "\"\n";
    print STUB "sysFlags=\"" . ${benchmark}->system_flags() . "\"\n";
    print STUB "feedFlags=\"" . ${benchmark}->feeder_flags() . "\"\n";
    close(STUB);


    # Invoke the setup script
    my $cmd = "env ASIM_CONFIG_MODEL=$model_name $setup_command $feed_arg $setup_args $srcdir $rundir";

    print STDOUT "COMMAND: $cmd\n";
    $sys_status = system($cmd);
    if ($sys_status) {
      print "Command failed\n";
      return 0;
    }

    return 1;
}

############################################################
# checkFileName -- confirm that a build tree name is unique.

my %uniqueFileNameTest;

sub checkFileName($$$)
{
    my $module = shift;
    my $src = shift;
    my $tgt = shift;

    if (exists($uniqueFileNameTest{$tgt})) {
        print STDERR "\nDuplicate name in build tree: ${tgt}\n";

        if (defined($src)) {
            print STDERR "   from " . $module->provides() . ": ${src}\n";
        }
        else {
            print STDERR "   generated for " . $module->provides() . "\n";
        }

        my @conflict = @{$uniqueFileNameTest{$tgt}};
        if (defined($conflict[1])) {
            print STDERR "   and " . $conflict[0]->provides() . ": $conflict[1]\n";
        }
        else {
            print STDERR "   and generated for " . $conflict[0]->provides() . "\n";
        }

        exit(1);
    }

    @{$uniqueFileNameTest{$tgt}} = ($module, $src);
}


############################################################
# build_build_tree

sub build_build_tree {
    my $modelfile = shift;

    my $sys_status;
    
    my $model = Asim::Model->new($modelfile);
    if (!defined($model)) {
      print "Failed to open model file.\n";
      return 0;
    }

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    ## NOTE: make target should come from argument to leap-configure
    $sys_status = system("make -C $builddir $buildopt");

    return ($sys_status == 0);
}

############################################################
# delete_build_tree
sub delete_build_tree {
    my $modelfile = shift;

    my $sys_status;

    my $model = Asim::Model->new($modelfile);
    if (!defined($model)) {
      print "Failed to open model file.\n";
      return 0;
    }

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }

    my $above_builddir = $builddir;
    $above_builddir =~ s/\/pm$//g; # strip off pm directory to make parent first
    $sys_status = system("rm -fr $above_builddir");

    return ($sys_status == 0);
}


############################################################
# configure_build_tree: Open a model produce build tree,
#                       populated with Makefiles, for it 
sub configure_build_tree {
    my $modelfile = shift;

    my $status;

    my $model = Asim::Model->new($modelfile);
    if (!defined($model)) {
      print "Failed to open model file.\n";
      return 0;
    }

    if (defined(&Asim::Model::embed_submodels)) {
      print "Using Asim::Model embed_submodels\n";
      $model->embed_submodels();
    } else {
      print "Using Asim::Model without embed_submodels\n";
    }

    # (0) validate model structure
    validate_model($model) || return 0;

    # (1) make directories
    make_dirs($model) || return 0;


    # (2a) make synthesized bsv files
    make_bsvfiles($model);

    # (2) make symlinks
    make_symlinks($model);

    # (3) generate makefiles from templates
    generate_makefile_include($model);
    generate_makefile_top($model);
    generate_makefile_sub($model);

    # (4) generate files needed by Xilinx tools
    Leap::Xilinx::generate_files_xilinx($model, $builddir);
    Leap::Xilinx::generate_files_synplify($model, $builddir);

    # (5) make interface files
    make_iface($model);

    return 1;
}

############################################################
# validate_model: Validate model structure

my %required_modules;

sub validate_model {
    my $model = shift;

    undef %required_modules;
    my $result = __validate_model($model->modelroot(), "");
    undef %required_modules;
    return $result;
}

sub __validate_model {
    my $module = shift;
    my $module_tree = shift;

    my $result = 1;

    if (!defined($module)) {
        print STDERR "Module of $model with path $module_tree is undefined\n";  
    }

    my $provides = $module->provides();

    if (exists($required_modules{$provides})) {
        print STDERR "Module ${provides} is required twice:\n";
        print STDERR "    $required_modules{$provides} and\n";
        print STDERR "    ${module_tree}\n";
        $result = 0;
    }

    if ($result) {
        $required_modules{$provides} = $module_tree;
        $module_tree .= "/$provides";
        foreach my $child ($module->submodules()) {
            $result &= __validate_model($child, $module_tree);
        }
    }

    return $result;
}

############################################################
# make_dirs: Make directories for build tree
sub make_dirs {
    my $model = shift;

    my $root = $model->modelroot();
    my $sys_status;

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }

    my $dir = Leap::Util::path_append($builddir,$Leap::Xilinx::tmp_xilinx_dir);
    $sys_status = system("mkdir -p " . $dir);
    $sys_status = system("mkdir -p " . $dir . "/xst_hdp");

    my $bdir = Leap::Util::path_append($builddir, $Leap::Bluespec::tmp_bsc_dir);
    $sys_status |= system("mkdir -p " . $bdir);

    # Hardware (hw) tree.
    my $hwdir = Leap::Util::path_append($builddir, "hw");

    $sys_status |= __make_dirs($root, $hwdir);
    $sys_status |= system("mkdir -p " . ${hwdir} . "/include/awb/provides");
    $sys_status |= system("ln -sfn awb " . ${hwdir} . "/include/asim");

    # Software (sw) tree.
    my $swdir = Leap::Util::path_append($builddir, "sw");

    $sys_status |= __make_dirs($root, $swdir);
    $sys_status |= system("mkdir -p " . ${swdir} . "/include/awb/provides");
    $sys_status |= system("mkdir -p " . ${swdir} . "/include/awb/restricted");
    $sys_status |= system("ln -sfn awb " . ${swdir} . "/include/asim");

    # Setup directory for scons library files
    $sys_status |= system("mkdir -p " . Leap::Util::path_append($builddir, "site_scons"));
    if ($sys_status) {
      print "Could not create site_scons dir\n";
      return 0;
    }

    if ($sys_status != 0) {
      print "Directory creation failed somewhere in $builddir\n";
      return 0;
    }

    return 1;
}

############################################################
# __make_dirs: Recursively make directories for build tree
sub __make_dirs {
    my $module = shift;
    my $parent_dir = shift;

    my $my_dir = Leap::Build::get_module_build_dir($module,$parent_dir);
    my $sys_status = 0;

    if (Leap::Build::is_synthesis_boundary($module)) {
	$sys_status |= system("mkdir -p $my_dir");

        my $bdir = Leap::Util::path_append($my_dir, $Leap::Bluespec::tmp_bsc_dir);
        $sys_status |= system("mkdir -p " . $bdir);
    }

    ## recurse
    Leap::Build::check_submodules_defined($module);

    foreach my $child ($module->submodules()) {
        $sys_status |= __make_dirs($child, $my_dir);
    }

    return $sys_status;
}

############################################################
# __make_wrappers: Recursively make wrappers for synthesis boundaries
sub __make_wrappers {
    my $module = shift;
    my $parent_dir = shift;
    my $isroot = shift;

    my $my_dir = Leap::Build::get_module_build_dir($module, $parent_dir);
    if (Leap::Build::is_synthesis_boundary($module)) {
        my $metatype = $module->provides();
        my $synth_id = Leap::Build::get_synthesis_boundary_name($module);

        # How many instances of the synthesis boundary?
        my $n_instances = Leap::Build::synthesis_instances($module);
        if ($n_instances == 0) {
            # Not specified.  Just one with basic interface.
            generate_wrapper($module, $my_dir, $isroot, $metatype, $synth_id);
        }
        else {
            # Multiple instances
            for (my $i = 0; $i < $n_instances; $i++) {
                generate_wrapper($module, $my_dir, $isroot,
                                 $metatype . "_$i",
                                 $synth_id . "($i, $n_instances)");
            }
        }

        $isroot = 0;
    } 
    
    ## recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
        __make_wrappers($child, $my_dir, $isroot);
    }
    
    return 1;
}

############################################################
# init_sim_config_file:  Create and write header to sim_config.h
sub init_sim_config_file($)
{
    my $sconfig = shift;
    my $sim_config = new IO::File($sconfig, 'w') or
        die("Failed to create $sconfig");

    $sim_config->print("//\n");
    $sim_config->print("// Synthesized header file for module parameters\n");
    $sim_config->print("//\n");
    $sim_config->print("//   This file was created by " . basename($0) . "\n");
    $sim_config->print("//\n");
    $sim_config->print("\n");


    $sim_config->print("#ifdef AWB_DEFS_ONLY\n");
    $sim_config->print("    #define AWB_DEFS_ONLY_WAS_DEFINED\n");
    $sim_config->print("#endif\n");
    $sim_config->print("#define AWB_DEFS_ONLY\n\n");

    $sim_config->print("#ifndef Register\n");
    $sim_config->print("#define Register(NAME,DESC,TYPE,VAR,VAL)\n");
    $sim_config->print("#endif\n\n");

    $sim_config->print("#ifndef Declare\n");
    $sim_config->print("#define Declare(DECL)\n");
    $sim_config->print("#endif\n\n");

    $sim_config->print("#ifndef RegisterDyn\n");
    $sim_config->print("#define RegisterDyn(NAME,DESC,TYPE,VAR)\n");
    $sim_config->print("#endif\n\n");

    $sim_config->print("#ifndef RegisterDynDict\n");
    $sim_config->print("#define RegisterDynDict(VAR,DICT_ENTRY)\n");
    $sim_config->print("#endif\n\n");

    return $sim_config;
}

############################################################
# dyn_params:  set up include files for parameter registration
sub dyn_params($)
{
    my $model = shift;

    ##
    ## Add some include files needed for parameter registration
    ##
    foreach my $fname ('config.h', 'param.h') {
        my $base;
        if ($fname eq 'config.h') {
            $base = Asim::resolve("base/leap-$fname");
            if (not defined($base)) {
                print "Could not resolve file base/leap-$fname. Is SEARCHPATH in awb.config wrong?\n";
                exit(1);
            }
        }       
        else {
            $base = Asim::resolve("base/$fname");
            if (not defined($base)) {
                print "Could not resolve file base/$fname. Is SEARCHPATH in awb.config wrong?\n";
                exit(1);
            }
        }
        if (defined($base)) {
            chomp($base);
            if ($base ne '') {
                system("ln -f -s $base " . Leap::Util::path_append($builddir, "sw/include/awb", $fname));
            }
        }
    }

    my $base_dir = Leap::Build::get_module_build_dir($model->modelroot(),
						      Leap::Util::path_append($builddir,"sw"));


    my $base = Asim::resolve("base/leap-config.cpp");
    chomp($base);
    if ($base ne '') {
        system("ln -f -s $base ${base_dir}/config.cpp");
    }

    ##
    ## Dynamic params
    ##
    open(PARAM, ">$base_dir/dynamic_params.cpp") or die("Failed to create $base_dir/dynamic_params.cpp");
    print PARAM "//\n";
    print PARAM "// Synthesized dynamic parameter manager\n";
    print PARAM "//\n";
    print PARAM "//   This file was created by " . basename($0) . "\n";
    print PARAM "//\n";
    print PARAM "\n";

    print PARAM "#include \"awb/provides/sim_config.h\"\n";
    print PARAM "#include \"awb/param.h\"\n";
    print PARAM "#include <strings.h>\n";
    print PARAM "#include \"asim/atoi.h\"\n\n";

    foreach my $param (sort keys(%dynamic_params)) {
        print PARAM "$dynamic_params{$param}[2] ${param} = ${param}_DYNDEFAULT;\n";
    }

    print PARAM "\n";
    print PARAM "bool SetParam(char *name, char *value)\n";
    print PARAM "{\n";
    print PARAM "    bool found = true;\n";

    my $first = 1;
    foreach my $param (sort keys(%dynamic_params)) {
        if ($first) {
            $first = 0;
            print PARAM "    ";
        }
        else {
            print PARAM "    else ";
        }
        print PARAM "if (strcasecmp(name, \"${param}\") == 0) {\n";
        if ($dynamic_params{$param}[2] eq "std::string") {
            print PARAM "        ${param} = value;\n";
        }
        else {
            print PARAM "        ${param} = atoi_general_unsigned(value);\n";
        }
        print PARAM "    }\n";
    }

    if ($first) {
        print PARAM "    found = false;\n";
    }
    else {
        print PARAM "    else {\n        found = false;\n    }\n";
    }

    print PARAM "    return found;\n";
    print PARAM "}\n\n";

    print PARAM "void ListParams(void)\n";
    print PARAM "{\n";
    foreach my $param (sort keys(%dynamic_params)) {
        my $value = $dynamic_params{$param}[1];
        $value =~ s/"/\\"/g;
        my $descr = $dynamic_params{$param}[3];
        $descr =~ s/"/\\"/g;
        print PARAM "    cout << \"    ${param}\ = \" << ${param} << '\\t' << \"${descr}\" << endl;\n";
    }
    print PARAM "}\n";

    close(PARAM);
}

############################################################
# make_bsvfiles: Make awb metatype bsv files
sub make_bsvfiles {
    my $model = shift;
    my $root = $model->modelroot();

    if (!defined($builddir)) {
        $builddir = $model->build_dir();
    }

    ##
    ## Parameters are all described in a sim_config.h so they can be written
    ## to the stats file.
    ##
    my $sim_config = init_sim_config_file(Leap::Util::path_append($builddir,"sw/include/awb/provides/sim_config.h"));

    __make_bsvfiles($root,
                    $sim_config,
                    Leap::Util::path_append($builddir,"hw"),
                    Leap::Util::path_append($builddir,"hw/include/awb/provides"),
                    Leap::Util::path_append($builddir,"sw/include/awb/provides"));

    $sim_config->print("\n#ifndef AWB_DEFS_ONLY_WAS_DEFINED\n");
    $sim_config->print("    #undef AWB_DEFS_ONLY\n");
    $sim_config->print("#endif\n");
    $sim_config->close();

    dyn_params($model);

    #
    # Hack to link model.h to <rootprovidestype>.h.
    # This is for legacy code that expects the root to be model.h
    #
    my $provides = $root->provides();

    if (! -e "${builddir}/sw/include/awb/provides/model.h") {
	system("cd ${builddir}/sw/include/awb/provides; ln -s $provides.h model.h");
    }

    return 1;
}

############################################################
# __make_bsvfiles: Recursively make awb metatype bsv files
sub __make_bsvfiles {
    my $module = shift;
    my $sim_config = shift;
    my $parent_dir = shift;
    my $hw_inc_dir = shift;
    my $sw_inc_dir = shift;

    # identify correct directory in build tree
    my $my_dir = Leap::Build::get_module_build_dir($module,$parent_dir);

    ##
    ## For each module generate two files:  a .bsh header file containing
    ## the module's parameters and a .bsv file that will be a wrapper for
    ## compiling the module.
    ##
    ## Clients of the module should INCLUDE the .bsh file, which both
    ## provides the module parameters and import's the Bluespec interface.
    ##

    my $provides = $module->provides();
    my $description = $module->description();
    my $bshfile = Leap::Util::path_append($hw_inc_dir,"$provides.bsh");
    my $paramsbshfile = Leap::Util::path_append($hw_inc_dir,"${provides}_params.bsh");
    # we compile the synthesis boundaries a little differently, except the top level.
    # this should all be moved to build pipeline
    my $bsvfile;
    if(Leap::Build::is_synthesis_boundary($module) && ! $module->isroot()) {
       $bsvfile = Leap::Util::path_append($my_dir,"${provides}_compile.bsv");
    } else {
       $bsvfile = Leap::Util::path_append($my_dir,"$provides.bsv");   
    }
    my $hfile   = Leap::Util::path_append($sw_inc_dir,"$provides.h");

    my @bsv_sources = $module->sources("BSV", "PUBLIC");

    $sim_config->print("\n#include \"awb/provides/${provides}.h\"\n");
    $sim_config->print("Register(\"Module_${provides}\",\"provides ${provides} (${description})\",UINT64,module_${provides},true)\n");

    unlink($bshfile);
    open(BSHFILE, ">$bshfile");
    unlink($paramsbshfile);
    open(PARAMSBSHFILE, ">$paramsbshfile");

    # Bluespec preprocessor doesn't like '-'
    my $safe_provides = $provides;
    $safe_provides =~ s/-/_/g;

    print BSHFILE "//\n";
    print BSHFILE "// Synthesized header file for module: $provides\n";
    print BSHFILE "//\n";
    print BSHFILE "//   This file was created by " . basename($0) . "\n";
    print BSHFILE "//\n";
    print BSHFILE "\n";

    print BSHFILE "`ifndef INCLUDED_MODULE_${safe_provides}\n";
    print BSHFILE "`define INCLUDED_MODULE_${safe_provides}\n";
    print BSHFILE "\n";

    print PARAMSBSHFILE "//\n";
    print PARAMSBSHFILE "// Synthesized header file for module: $provides\n";
    print PARAMSBSHFILE "//\n";
    print PARAMSBSHFILE "//   This file was created by " . basename($0) . "\n";
    print PARAMSBSHFILE "//\n";
    print PARAMSBSHFILE "\n";

    print PARAMSBSHFILE "`ifndef INCLUDED_MODULE_${safe_provides}_PARAMS\n";
    print PARAMSBSHFILE "`define INCLUDED_MODULE_${safe_provides}_PARAMS\n";
    print PARAMSBSHFILE "\n";

    # add defines for parameters
    my @p = ();
    push(@p, $module->parameters());

    foreach my $p (@p) {
      my $pname = $p->name();
      my $pvalue = $p->value();
      
      if ($p->dynamic()) {
          $pname .= "_DYNDEFAULT";
      }

      print PARAMSBSHFILE "`define $pname $pvalue\n";

      ## Make SYNTH_INSTANCES globally useful
      if ($pname eq "SYNTH_INSTANCES") {
          print PARAMSBSHFILE "`define " . uc($provides) . "_$pname $pvalue\n";
      }

      ##
      ## This hack works around a weakness in Bluespec's preprocessor.  There
      ## is an ifdef test but no comparison (e.g. `if FOO = 0).  So we can at
      ## least use awb parameters as preprocessor booleans, we define
      ## a special name when the value of a predicate is 0.
      ##
      if ($p->isInt() && ($pvalue == 0)) {
          print PARAMSBSHFILE "`define ${pname}_Z $pvalue\n";
      }
    }
    print PARAMSBSHFILE "\n";

    ##
    ## SCons build rules may override parameters at compile time.
    ##
    print PARAMSBSHFILE "`include \"awb/provides/${provides}_params_override.bsh\"\n";
    print PARAMSBSHFILE "\n";

    # .bsh (include) files get included in the synthesized headers.  That way
    # a module can declare a set of public files that get included as source.
    # Bluespec would normally import a compiled file and not see the source.
    foreach my $f ($module->sources("BSH", "PUBLIC")) {
        print PARAMSBSHFILE "`include \"$f\"\n";
        if ($f eq "${provides}.bsv") {
            print STDERR "File name clash:  interface ${provides} uses a source file with the same name!\n";
            exit(1);
        }
        if ($f eq "${provides}_compile.bsv") {
            print STDERR "File name clash:  interface ${provides} uses a source file with the same name!\n";
            exit(1);
        }
    }

    print PARAMSBSHFILE "\n";
    print PARAMSBSHFILE "`endif  // INCLUDED_MODULE_${safe_provides}\n";

    close (PARAMSBSHFILE); 
    print BSHFILE "`include \"awb/provides/${provides}_params.bsh\"\n";
    if (@bsv_sources) {
        print BSHFILE "\n";
        print BSHFILE "`ifndef BUILDING_MODULE_${safe_provides}\n";
        print BSHFILE "    import ${provides}::*;\n";
        print BSHFILE "`endif\n";
    }

    print BSHFILE "\n";
    print BSHFILE "`endif  // INCLUDED_MODULE_${safe_provides}\n";

    close(BSHFILE);

    checkFileName($module, undef, $bsvfile);
    unlink("${bsvfile}");
    if (@bsv_sources) {
        open(BSVFILE, ">${bsvfile}");

        print BSVFILE "//\n";
        print BSVFILE "// Synthesized compilation file for module: $provides\n";
        print BSVFILE "//\n";
        print BSVFILE "//   This file was created by " . basename($0) . "\n";
        print BSVFILE "//\n";
        print BSVFILE "\n";

        # Prevent circular imports
        print BSVFILE "`define BUILDING_MODULE_${safe_provides}\n";
        print BSVFILE "`include \"awb/provides/${provides}_params.bsh\"\n";
        print BSVFILE "\n";

        # Add includes of public and private bsc files.  Skip .bsh files since they
        # were included above in the synthesized bsh file.
        if ($public) {
            foreach my $f ($module->sources("BSV", "PUBLIC")) {
                print BSVFILE "`include \"$f\"\n";
                if ($f eq "${provides}.bsv") {
                    print STDERR "File name clash:  interface ${provides} uses a source file with the same name!\n";
                    exit(1);
                }
            }
        }
    }

    close(BSVFILE);

    # C++ header
    unlink($hfile);
    open(HFILE, ">$hfile");

    print HFILE "//\n";
    print HFILE "// Synthesized header file for module: $provides\n";
    print HFILE "//\n";
    print HFILE "//   This file was created by " . basename($0) . "\n";
    print HFILE "//\n";
    print HFILE "\n";
    ## In some cases, we use strings in the generated header. If we
    ## are in C++ this makes sense. However, sometimes we import
    ## headers into C code (typically bdpi), so we protect those
    ## compilations with an ifdef.  If the included header in C uses a
    ## string, then obviously it will fail to compile, but that's the
    ## programmer's problem. 
    print HFILE "#ifdef __cplusplus\n";
    print HFILE "    #include <string>\n";
    print HFILE "#endif\n";
    print HFILE "#include \"asim/syntax.h\"\n";
    ##
    ## Add defines for parameters.  These go before the tests for AWB_DEFS_ONLY
    ## and whether the include file has already been included so that it
    ## is possible to load just parameter values and, on a later pass in the
    ## same compilation, to load the full include file.
    ##
    @p = ();
    push(@p, $module->parameters());

    foreach my $p (@p) {
        my $pname = $p->name();
        my $pvalue = $p->value();
      
        ## SYNTH_BOUNDARY is a special value meaningful for hardware
        ## and not software.  It triggers redefined symbol warnings,
        ## so don't emit in .h files.
        ## COMPUTE_PLATFORM also falls in this category
        my $isSynthBoundary = ($pname eq "SYNTH_BOUNDARY");
        my $isComputePlatform = ($pname eq "COMPUTE_PLATFORM");
        my $isSynthInstances = ($pname eq "SYNTH_INSTANCES");

        if (! $p->isString() && ! $p->isInt()) {
            # Unknown parameter type
            if (! $isSynthBoundary && ! $isComputePlatform) {
                print HFILE "#define $pname $pvalue\n";
            }
            if ($p->dynamic()) {
                print STDERR "Dynamic parameter $provides $pname must be string or integer\n";
                exit(1);
            }
        }
        else {
            if (exists($all_params{$pname})) {
                print STDERR "Parameter $pname is defined twice ($all_params{$pname} and $provides)\n";
                exit(1);
            }
            $all_params{$pname} = $provides;

            my $type = $p->isInt() ? "UINT64" : "std::string";
            my $descr = $p->description();

            if (! $p->dynamic()) {
                if (! $isSynthBoundary) {
                    if ($isSynthInstances) {
                        # Make a unique name for SYNTH_INSTANCES
                        print HFILE "#define " . uc($provides) . "_$pname $pvalue\n";
                    }
                    else {
                        print HFILE "#define $pname $pvalue\n";
                    }
                }
                $sim_config->print("Register(\"Param_${pname}\",\"${descr}\",${type},param_${pname},${pname})\n");
            }
            else {
                # Dynamic parameter.  Declare a default value that may be
                # overridden during build.  (That default may then be overridden
                # again at run time.
                print HFILE "#define ${pname}_DYNDEFAULT $pvalue\n";
            }
        }
    }
    print HFILE "\n";

    ##
    ## SCons build rules may override parameters at compile time.
    ##
    print HFILE "#include \"${provides}_params_override.h\"\n";
    print HFILE "\n";

    print HFILE "#ifndef AWB_DEFS_ONLY\n\n";

    print HFILE "#ifndef INCLUDED_MODULE_$provides\n";
    print HFILE "#define INCLUDED_MODULE_$provides\n";
    print HFILE "\n";

    foreach my $p (@p) {
        my $pname = $p->name();
        my $pvalue = $p->value();
      
        if ($p->dynamic()) {
            my $type = $p->isInt() ? "UINT64" : "std::string";
            my $descr = $p->description();

            print HFILE "extern ${type} ${pname};\n";

            $sim_config->print("Declare(extern ${type} ${pname})\n");
            $sim_config->print("RegisterDyn(\"Param_${pname}\",\"${descr} (dynamic)\",${type},${pname})\n");
            if ($p->isInt()) {
                $sim_config->print("RegisterDynDict(${pname},PARAMS_" . uc($safe_provides) . "_" . uc($pname) . ")\n");
            }

            $dynamic_params{$pname} = [$safe_provides, $pvalue, $type, $p->description()];
        }
    }
    print HFILE "\n";

    # add includes for all public C/C++ include files
    if ($public) {
        foreach my $f ($module->sources("H", "PUBLIC")) {
            print HFILE "#include \"../restricted/${f}\"\n";
        }
    }

    print HFILE "#endif  // INCLUDED_MODULE_$provides\n";
    print HFILE "\n";
    print HFILE "#endif  // AWB_DEFS_ONLY\n";

    close(HFILE);
    
    
    # recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__make_bsvfiles($child, $sim_config, $my_dir, $hw_inc_dir, $sw_inc_dir);
    }

    return 1;
}

############################################################
# make_symlinks: Generate symlinks in build tree to source
#                files and to model apm file (for connect script)
sub make_symlinks {
    my $model = shift;

    my $root = $model->modelroot();

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    my $hw_dir = Leap::Util::path_append($builddir, "hw");
    __make_symlinks($root, $hw_dir, undef, '^(CPP|H|DICT|RRR)$', '.*');
    
    my $sw_dir = Leap::Util::path_append($builddir, "sw");
    my $restricted_dir = Leap::Util::path_append($builddir, "sw/include/awb/restricted");
    __make_symlinks($root, $sw_dir, $restricted_dir, '^$', '^(CPP|H)$');

    return 1;
}

############################################################
# __make_symlinks: Recursively generate symlinks in build 
#                  tree
sub __make_symlinks {
    my $module = shift;
    my $parent_dir = shift;
    my $restricted_dir = shift;
    my $type_exclude_regexp = shift;
    my $type_include_regexp = shift;

    # identify correct directory in build tree
    my $my_dir = Leap::Build::get_module_build_dir($module,$parent_dir);

    # for each src file, generate symlink in $my_dir
    my $base_dir = $module->base_dir();
    my @l = ();
    my @restr = ();

    my @types = $module->source_types();
    foreach my $t (@types) {
        if (($t =~ /$type_include_regexp/) && ! ($t =~ /$type_exclude_regexp/)) {
            if ($private) {
                push(@l, $module->sources($t, "PRIVATE"));
            }
            if ($public) {
                push(@l, $module->sources($t, "PUBLIC"));
                if (defined($restricted_dir)) {
                    push(@restr, $module->sources($t, "PUBLIC"));
                }
            }
        }
    }

    foreach my $f (@l) {
        my $src = Asim::resolve(Leap::Util::path_append($base_dir,$f));
        my $tgt = Leap::Util::path_append($my_dir,$f);

        if (! defined($src) || ! -e $src) {
          Leap::Util::WARN_AND_DIE("Module file $f does not exist in $base_dir");
        }
        
        checkFileName($module, $src, $tgt);

        # make src relative
        my $relsrc = File::Spec->abs2rel($src, dirname($tgt));
        $status = system("ln -f -s $relsrc $tgt");
    }

    ##
    ## A second set of links in the "src/include/awb/restricted" directory
    ## so the public include hierarchy is simpler in C++.
    ##
    foreach my $f (@restr) {
        my $src = Asim::resolve(Leap::Util::path_append($base_dir,$f));
        my $tgt = Leap::Util::path_append($restricted_dir,$f);

        if (! -e $src) {
          Leap::Util::WARN_AND_DIE("Module file $f does not exist in $base_dir");
        }
        
        # make src relative
        my $relsrc = File::Spec->abs2rel($src, dirname($tgt));
        $status = system("ln -f -s $relsrc $tgt");
    }

    # recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
        __make_symlinks($child, $my_dir, $restricted_dir,
                        $type_exclude_regexp, $type_include_regexp);
    }

    return 1;
}


sub note_builddir($) {
    my $replacements_r = shift;

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }

    # @BUILD_DIR@
    Leap::Util::hash_set($replacements_r,'@BUILD_DIR@',$builddir);
}

############################################################
# generate_makefile_include: Collect template replacement 
#                            values for model, and generate
#                            $(APM)/pm/Makefile.include
sub generate_makefile_include {
    my $model = shift;

    my $template = Leap::Build::get_makefile_include_template($model);
    return if (! defined($template));

    my $replacements_r = Leap::Util::empty_hash_ref();

    Leap::Util::common_replacements($model, $replacements_r);
    note_builddir($replacements_r);

    # gather other info recursively
    __generate_makefile_include($model->modelroot(),"hw",$replacements_r);

    my $makefile = Leap::Util::path_append($builddir,"Makefile.include");
    Leap::Templates::do_replacements($template,$makefile,$replacements_r);
}

############################################################
# __generate_makefile_include: Recursively collect replacements
#                              for Makefile.include
sub __generate_makefile_include {
    my $module = shift;
    my $parent_dir = shift;
    my $replacements_r = shift;

    my $my_dir = Leap::Build::get_module_build_dir($module,$parent_dir);
    if (Leap::Build::is_synthesis_boundary($module)) {
	# @ALL_HW_DIRS@
	Leap::Util::hash_append($replacements_r,":",'@ALL_HW_DIRS@',$my_dir);
    }

    # recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__generate_makefile_include($child,$my_dir,$replacements_r);
    }

}

############################################################
# generate_makefile_top: Collect template replacement values
#                        for model, and generate 
#                        $(APM)/pm/Makefile
sub generate_makefile_top {
    my $model = shift;
    
    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }
    
    my $replacements_r = Leap::Util::empty_hash_ref();
    
    Leap::Util::common_replacements($model, $replacements_r);
    note_builddir($replacements_r);

    #@ROOT_DIR_MODEL@
    my $root = $model->modelroot();

    if (Leap::Build::is_synthesis_boundary($root)) {     
	Leap::Util::hash_set($replacements_r,'@ROOT_DIR_MODEL@',$root->provides());
    } else {
	Leap::Util::WARN_AND_DIE("Root module must be a synthesis boundary");
    }

    Leap::Util::hash_set($replacements_r, '@ROOT_DIR_HW@', "hw");
    Leap::Util::hash_set($replacements_r, '@ROOT_DIR_SW@', "sw");

    Leap::Util::hash_set($replacements_r, '@ROOT_DIR_HW_INC@', "hw/include");
    Leap::Util::hash_set($replacements_r, '@ROOT_DIR_SW_INC@', "sw/include");

    # gather other info recursively
    __generate_makefile_hw_top($root,"hw",$replacements_r, 1);
    my $isHybridModel = __generate_makefile_sw_top($root,"sw",$replacements_r, 1);

    # Add generated interface include directory to ALL_HW_DIRS
    Leap::Util::hash_append($replacements_r, ":", '@ALL_HW_DIRS@', "iface/build/include");
    Leap::Util::hash_append($replacements_r, ":", '@ALL_HW_DIRS@', "iface/build/hw");

    # Generate the makefile
    my $template = Leap::Build::get_makefile_top_template($model);
    if (defined($template)) {
        my $makefile = Leap::Util::path_append($builddir,"Makefile");
        Leap::Templates::do_replacements($template,$makefile,$replacements_r);
    }

    # Generate scons files
    $template = Leap::Build::get_scons_root_template($model, 'top');
    if (defined($template)) {
        my $scons = Leap::Util::path_append($builddir, "SConstruct");
        Leap::Templates::do_replacements($template, $scons, $replacements_r);
    }

    # Copy scons python libraries
    # By fiat of scons, these files live in ./site_scons directory
    # we have to set up the scons/python seach path here as well
    
    __generate_build_libraries($root, Leap::Util::path_append($builddir, "/site_scons/"));

    ##
    ## Add a model description stub for benchmarks
    ##
    ##   The output of this file must be simple so it can be parsed in multiple
    ##   scripting languages.  For /bin/sh it should just be loadable.  For
    ##   Perl or Python it should be just a series of assignments.
    ##
    mkdir("${builddir}/config");
    open(STUB, "> ${builddir}/config/env.sh") or Leap::Util::WARN_AND_DIE("Failed to open ${builddir}/config/env.sh");
    print STUB "#!/bin/sh\n";
    print STUB "#\n";
    print STUB "# Generated automatically by leap-configure\n";
    print STUB "#\n\n";
    print STUB "isHybridModel=${isHybridModel}\n";
    close(STUB);
    
}


############################################################
# __generate_build_libraries: Recursively set up python modules
#                             for inclusion in build process
sub __generate_build_libraries {
    my $module = shift;
    my $base_dir = shift;

    my $targetdir = Leap::Util::path_append($base_dir, $module->provides);

    # We now dump all modules since python may wish to look at module params
    my @libraries = Leap::Build::get_scons_library($module);
    my @privates = Leap::Build::get_scons_private($module);
    

    my $sys_status = system("mkdir -p " . Leap::Util::path_append($base_dir, "/" . $module->provides . "/"));
    if ($sys_status) {
	print "Could not create " . Leap::Util::path_append($base_dir, "/" . $module->provides . "/") . "\n";
	return 0;
    }
	
    #need to have __init__.py in the directory
    #this must define the __all__ variable
    open(INIT,"> " . Leap::Util::path_append($base_dir, "/" . $module->provides . "/__init__.py"));
    open(CONFIG,"> " . Leap::Util::path_append($base_dir, "/" . $module->provides . "/config.py"));
    if ($sys_status) {
	print "Could not create " . Leap::Util::path_append($base_dir, "/" . $module->provides . "/__init__.py") . "\n";
	return 0;
    }        
    
    foreach my $library (@libraries) {
	# Make a symlink
        # rebase the simlink for portability
        unless(-e $library) {
           my $module_name = $module->name; 
           print "Failed to find python library in module ${module_name}: $library, does it exist?\n";
           return 0;
	}

        my $relsrc = File::Spec->abs2rel($library, $targetdir);
	my $buildpath = Leap::Util::path_append($targetdir , basename($library));
	my  @fileparts = split(/\./,basename($library));
	print INIT "from $fileparts[0] import *\n";
	`ln -fs $relsrc $buildpath`;
    }

    # private files are not included in the config.py -- this helps with scoping
    foreach my $private (@privates) {
        # rebase the simlink for portability
        my $relsrc = File::Spec->abs2rel($private, $targetdir);
	my $buildpath = Leap::Util::path_append($targetdir , basename($private));
	`ln -fs $relsrc $buildpath`;
    }

    # dump out python parameters
    print CONFIG "awbParams = {\n";
    my @parameters = $module->parameters();
    
    foreach my $p (@parameters) {
	my $pname = $p->name();
	my $pvalue = $p->value();
	
	if ($pname ne "SYNTH_BOUNDARY") {  
            if ($p->dynamic()) {
                $pname .= "_DYNDEFAULT";
            }

            if (Scalar::Util::looks_like_number($pvalue)) {
                print CONFIG "    '${pname}': ${pvalue},\n";
            }
            elsif ($pvalue =~ /^['"].*['"]$/) {
                # String already quoted
                print CONFIG "    '${pname}': ${pvalue},\n";
            }
            else {
                # String needs quotes
                print CONFIG "    '${pname}': \"${pvalue}\",\n";
            }
	}
    }

    print CONFIG "}\n";
        
    close(INIT);
    close(CONFIG);
    

    #recurse on children, but do not change path.  
    #this is due to the python naming scheme

    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
        __generate_build_libraries($child,$base_dir);
    }     
}
############################################################
# __generate_makefile_hw_top: Recursively collect replacements
#                             for Makefile.top
sub __generate_makefile_hw_top {
    my $module = shift;
    my $parent_dir = shift;
    my $replacements_r = shift;
    my $is_root = shift;

    my $my_dir = Leap::Build::get_module_build_dir($module,$parent_dir);
        
    if ($module->sources("BSV", "PUBLIC")) {
        # stick these GEN_BSVS in the generated list
        my $mod_bsv = $module->provides() . ".bsv";
        $module->addgenerated("BSV",$mod_bsv);
    }

    if (Leap::Build::is_synthesis_boundary($module)) {

        # @ALL_HW_DIRS@
        Leap::Util::hash_append($replacements_r,":",'@ALL_HW_DIRS@',$my_dir);

        my $synth_instances = Leap::Build::synthesis_instances($module);
        my $fileroot = Leap::Build::get_wrapper($module);
          
        if ($synth_instances == 0) {
            # Unspecified SYNTH_INSTANCES.

            # @SYNTH_WRAPPERS@
            if ($is_root) {
                Leap::Util::hash_set($replacements_r, '@SYNTH_TOP@', $fileroot);
            }
            else {
                Leap::Util::hash_append($replacements_r," ",'@SYNTH_WRAPPERS@', $fileroot);
            }

            
            # This stuff can be retained for now, but should eventually
            # be replaced in the python code, as Bluespec should know it
            # generates these files.

            # @GEN_VS@ - bsc generated .v files
            my $v_file = "$fileroot.v";
            Leap::Util::hash_append($replacements_r," ",'@GEN_VS@',Leap::Util::path_append($my_dir, $Leap::Bluespec::tmp_bsc_dir, $v_file));

            # @GEN_BAS@
            my $ba_file = "$fileroot.ba";
            Leap::Util::hash_append($replacements_r," ",'@GEN_BAS@',Leap::Util::path_append($my_dir, $Leap::Bluespec::tmp_bsc_dir, $ba_file));
        }
        else {
            # Multiple SYNTH_INSTANCES
            for (my $i = 0; $i < $synth_instances; $i++) {
                my $name = "mk_" . Leap::Build::make_instance_wrapper_name($module->provides, $i);

                # @SYNTH_WRAPPERS@
                Leap::Util::hash_append($replacements_r," ",'@SYNTH_WRAPPERS@', $name);

                # @GEN_VS@ - bsc generated .v files
                my $v_file = "$name.v";
                Leap::Util::hash_append($replacements_r," ",'@GEN_VS@',Leap::Util::path_append($my_dir, $Leap::Bluespec::tmp_bsc_dir, $v_file));

                # @GEN_BAS@
                my $ba_file = "$name.ba";
                Leap::Util::hash_append($replacements_r," ",'@GEN_BAS@',Leap::Util::path_append($my_dir, $Leap::Bluespec::tmp_bsc_dir, $ba_file));
            }
        }

        # @GEN_CXXS@ and @GEN_HS@ are local to the toplevel directory
        my $cxx_file = "$fileroot.cxx";
        Leap::Util::hash_append($replacements_r," ",'@GEN_CXXS@',Leap::Util::path_append($cxx_file));
        my $h_file = "$fileroot.h";
        Leap::Util::hash_append($replacements_r," ",'@GEN_HS@',Leap::Util::path_append($h_file));
        
        # @GEN_O_DEPS@ makes sure generated .cxx files are compiled in the right order
        my $my_o = Leap::Build::make_module_name(Leap::Build::make_wrapper_name($module->provides()));
        my $parent = Leap::Build::make_module_name(Leap::Build::make_wrapper_name($parent_dir));
        $parent =~ s/.*\///;
        if (!$is_root)
        {
          Leap::Util::hash_append($replacements_r," ",'@GEN_O_DEPS@',"\n\$(TMP_BSC_DIR)/$parent.o: \$(TMP_BSC_DIR)/$my_o.o\n");
        }
    }

    foreach my $key ($module->generatedtypes()) {
        foreach my $file ($module->generated($key)) {
            Leap::Util::hash_append($replacements_r," ",'@GIVEN_'.$key.'S@',Leap::Util::path_append($my_dir,$Leap::Bluespec::tmp_bsc_dir,$file));
        } 
    }

    foreach my $key ($module->sourcetypes()) {
        foreach my $file ($module->sources($key, "*")) {
            Leap::Util::hash_append($replacements_r," ",'@GIVEN_'.$key.'S@',Leap::Util::path_append($my_dir,$file));
        } 
    }

    ## @BDPI_CS@

    foreach my $f ($module->sources("BDPI_C", "*")) {
        # **** HACK **** only push C files, not H files. TODO: Need a more general separation
        #                between to-be-compiled source files and not-to-be-compiled header files
        # **** /HACK ****
        if ($f =~ /\.h$/) {
            # do nothing
        }
        else {
            Leap::Util::hash_append($replacements_r," ",'@BDPI_CS@',Leap::Util::path_append($my_dir, $f));
        }
    }

    ## @SW_LIBS@
    my $need_global_includes = 0;
    foreach my $lib ($module->library()) {
        my $f = Asim::resolve($lib);
        if (defined $f) {
            Leap::Util::hash_append($replacements_r," ",'@SW_LIBS@',$f);
            # Automatically add library directory as an include path
            Leap::Util::hash_append($replacements_r," ",'@SW_INC_DIRS@',Leap::Util::path_append(dirname($f),'include'));
        }
        else {
            my $found_in_env = 0; 
            #See if the user library path will resolve the library
            #this assumes that the C code will use gcc.
            if (exists $ENV{"LIBRARY_PATH"}) {
                my $env_library_path = $ENV{"LIBRARY_PATH"};
                foreach my $path (split(/:/,$env_library_path)) {
                    chomp($path);
                    my $f = $path. "/" . basename($lib);
                    if( -e $f){
                        $found_in_env = 1;
                        Leap::Util::hash_append($replacements_r," ",'@SW_LIBS@', $f);
                    } 
		} 
	    }

            # Try for one last location in the installed $libdir
            $f = Asim::Libdir() . "/" . basename($lib);
            if (-e $f) {
                print "AWB resolver using installed version of library $lib.\n";
                # We found it in the install dir.
                Leap::Util::hash_append($replacements_r," ",'@SW_LIBS@',$f);
                $need_global_includes = 1;
            }
            elsif(!$found_in_env) {
                print "AWB resolver did not find library $lib nor was it in the scope of LIBRARY_PATH.\n";
            }
            
        }
    }

    ## @SW_SYS_LIBS
    foreach my $sysl ($module->syslibrary()) {
        # These are taken on faith from the user and given to the linker.
        Leap::Util::hash_append($replacements_r," ",'@SW_LINK_LIBS@',$sysl);
    }

    ## @SW_INC_DIRS@
    foreach my $inc ($module->include()) {
        my $f = Asim::resolve($inc);
        if (defined $f) {
            Leap::Util::hash_append($replacements_r," ",'@SW_INC_DIRS@',$f);
        }
        else {
            print "AWB resolver did not find include directory $inc.\n";
        }
    }

    # Did we need to include the installed includedir?
    if ($need_global_includes) {
        Leap::Util::hash_append($replacements_r," ",'@SW_INC_DIRS@', Asim::Includedir());
    }

    # recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
        __generate_makefile_hw_top($child,$my_dir,$replacements_r, 0);
    }


    ## @MODULE_LIST@
    ## generate data structures for use in scons python code
    ## we do this last so as to collect the GENerated files uttered above.
    my $pythonRepresentation = Leap::Build::pythonize_module($module);
    Leap::Util::hash_append($replacements_r," ",'@MODULE_LIST@',$pythonRepresentation);

}


############################################################
# __generate_makefile_hw_top: Recursively collect replacements
#                             for Makefile.top
#
#     Returns 1 if the model has a software component, otherwise 0.
#
sub __generate_makefile_sw_top {
    my $module = shift;
    my $parent_dir = shift;
    my $replacements_r = shift;
    my $is_root = shift;

    my $isHybridModel = 0;

    my $my_dir = Leap::Build::get_module_build_dir($module,$parent_dir);

    ## @GIVEN_CS@

    foreach my $f ($module->sources("CPP", "*")) {
        Leap::Util::hash_append($replacements_r," ",'@GIVEN_CS@',Leap::Util::path_append($my_dir, $f));
        $isHybridModel = 1;
    }

    # recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
        $isHybridModel |= __generate_makefile_sw_top($child,$my_dir,$replacements_r, 0);
    }

    return $isHybridModel;
}


############################################################
# generate_makefile_sub: Collect template replacement values
#                        for model, and generate a Makefile
#                        for each directory in the build tree
#                        (one per synthesis boundary) 
sub generate_makefile_sub {
    my $model = shift;
    
    my $replacements_r = Leap::Util::empty_hash_ref();
    Leap::Util::common_replacements($model, $replacements_r);

    note_builddir($replacements_r);

    __generate_makefile_sub($model, $model->modelroot(), "hw",
                            Leap::Build::get_scons_root_template($model, "hw"),
                            $replacements_r);
    __generate_makefile_sub($model, $model->modelroot(), "sw",
                            Leap::Build::get_scons_root_template($model, "sw"),
                            $replacements_r);
}

############################################################
# __generate_makefile_sub: Recursively collect template 
#                          replacement values and generate
#                          Makefiles, one per directory
#                          in the build tree
sub __generate_makefile_sub {
    my $model = shift;
    my $module = shift;
    my $parent_dir = shift;
    my $scons_template = shift;
    my $replacements_r = shift;

    my $current_replacements_r = $replacements_r;
    my $my_dir = $parent_dir;

    if (Leap::Build::is_synthesis_boundary($module)) {
	# OVERRIDE non-synth-boundary settings
	# 1. instantiate new hash for synthesis boundary
	$current_replacements_r = Leap::Util::empty_hash_ref();
	# 2. update path
	$my_dir = Leap::Util::path_append($parent_dir,$module->provides());

 	## @DIR@
	Leap::Util::hash_set($current_replacements_r,'@DIR@',$module->provides());

	## @FULL_DIR@
	Leap::Util::hash_set($current_replacements_r,'@FULL_DIR@',"$builddir/$my_dir");

	## @DOTS_TO_MAKEFILE_INCL@
	my $dots_path = $my_dir;
	$dots_path =~ s/([^\/])+/../g;
	Leap::Util::hash_set($current_replacements_r,'@DOTS_TO_MAKEFILE_INCL@',$dots_path);
        
        my $my_bsv;
        my $n_instances = Leap::Build::synthesis_instances($module);
        if ($n_instances == 0) {
            # Number of instances not specified.  Build just one.
            my $my_wrap = Leap::Build::make_wrapper_name($module->provides());
            $my_bsv = "${my_wrap}.bsv";
        }
        else {
            # Multiple instances.  Build all the wrapper files.
            for (my $i = 0; $i < $n_instances; $i++) {
                $my_bsv .= " " if ($i != 0);

                my $my_wrap = Leap::Build::make_instance_wrapper_name($module->provides(), $i);
                $my_bsv .= "${my_wrap}.bsv";
            }
        }

        Leap::Util::hash_append($current_replacements_r," ",'@WRAPPER_BSVS@',$my_bsv);
    }

    ## @SUBDIRS@ & @SUBDIR_BAS@
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	
	if (Leap::Build::is_synthesis_boundary($child)) {
	    my $subdir = $child->provides();
	    Leap::Util::hash_append($current_replacements_r," ",'@SUBDIRS@',$subdir);
            generate_surrogate_deps($current_replacements_r, $child, '');

	}
    }

    ## FOR BOTH SYNTH & NON_SYNTH
    ## @BSVS@ & @SRCS@ @CSRCS@

    if ($model->modelroot() == $module) {
        # At top level add a few CPP files automatically provided for the model
        Leap::Util::hash_append($current_replacements_r, " ", '@CSRCS@', "config.cpp");
        Leap::Util::hash_append($current_replacements_r, " ", '@CSRCS@', "dynamic_params.cpp");
    }

    my $deps = "";
    my $mod_bsv = $module->provides() . ".bsv";

    if ($private) {
        foreach my $f ($module->sources("BSV", "PRIVATE")) {
            Leap::Util::hash_append($current_replacements_r, " ", '@BSVS@', $f);
            $deps = $deps . " $f";
        }
        foreach my $f ($module->sources("CPP", "PRIVATE")) {
            Leap::Util::hash_append($current_replacements_r, " ", '@CSRCS@', $f);
            # $deps = $deps . " $f";
        }
    }
    if ($public) {
        foreach my $f ($module->sources("BSV", "PUBLIC")) {
            Leap::Util::hash_append($current_replacements_r, " ", '@BSVS@', $f);
            $deps = $deps . " $f";
        }
        foreach my $f ($module->sources("CPP", "PUBLIC")) {
            Leap::Util::hash_append($current_replacements_r, " ", '@CSRCS@', $f);
            # $deps = $deps . " $f";
        }
    }

    # collect BDPI-exported names
    my @bdpi_names = Leap::Build::get_bdpi_names($module);
    foreach my $n (@bdpi_names) {
        my $fname = "$n.ba";
	    Leap::Util::hash_append($current_replacements_r, " ", '@BDPI_BAS@', $fname);
    }

    # Add module to build list if it has sources that need to be built
    if ($module->sources("BSV", "PUBLIC")) {
        # stick these GEN_BSVS in the generated list
        Leap::Util::hash_append($current_replacements_r, " ", '@GEN_BSVS@', $mod_bsv);
    }

    #recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__generate_makefile_sub($model,$child,$my_dir,$scons_template,$current_replacements_r);
    }

    if (!defined($builddir)) {
      $builddir = $model->build_dir();
    }

    # on the way up, possibly generate makefile
    if (Leap::Build::is_synthesis_boundary($module)) {

        ## We appear to require model root for imports
        ## This could be classified as a hack, however.
        #@ROOT_DIR_MODEL@
        my $root = $model->modelroot();
        Leap::Util::hash_set($current_replacements_r,'@ROOT_DIR_MODEL@',$root->provides());
        # Generate scons file
        if (defined($scons_template)) {
            my $scons = Leap::Util::path_append($builddir, $my_dir, "SConscript");
            Leap::Templates::do_replacements($scons_template, $scons, $current_replacements_r);
        }
    }
}


#############################################################
# Generate surrogate dependencies for turning wires back to
# connections via leap-connect

sub generate_surrogate_deps
{
  my $replacements_r = shift;
  my $module = shift;
  my $dir = shift;
  
  my $surrogate = $module->provides();
  my $wrapper = Leap::Build::make_wrapper_name($surrogate);
  
  # @SURROGATE_DEPS@ ensures surrogates are re-generated as necessary
  my $run_connection = "\$(CONNECTION_SCRIPT) \$(APM_FILE) \$@";
  Leap::Util::hash_append($replacements_r," ",'@SURROGATE_DEPS@',"\n$dir/$surrogate.bsv: $dir/$surrogate/\$(TMP_BSC_DIR)/$wrapper.bi\n\t$run_connection\n");
  
#  my $child_wrap = Leap::Build::make_wrapper_name($surrogate);
#  my $child_bsv = "${surrogate}/${child_wrap}.bsv";
#  $child_bsv = "$dir/$child_bsv" if ($dir ne '');
#  Leap::Util::hash_append($replacements_r," ",'@WRAPPER_BSVS@',$child_bsv);
  
  foreach my $child ($module->submodules()) {
    if (Leap::Build::is_synthesis_boundary($child)) {
      my $subdir = $child->provides();
      my $subdir_wrapper = Leap::Build::make_wrapper_name($subdir);
      
      generate_surrogate_deps($replacements_r, $child, Leap::Util::path_append($dir, $surrogate));
    }
  }
}


#############################################################
# Generate a wrapper file that turns all Connections to wires
# at a synthesis boundary.

sub generate_wrapper {
    my $module = shift;
    my $dirname = shift;
    my $isroot = shift;
    my $metatype = shift;
    my $synth_id = shift;

    my $usesmartsynthesisboundaries = 1;

    my $wrapper = Leap::Build::make_wrapper_name($metatype) . ".bsv";
    
    my $synth_name = Leap::Build::make_wrapper_name($metatype);
    my $module_name = Leap::Build::make_module_name($synth_name);

    unlink("$dirname/$wrapper");
    open(WRAPPER, "> $dirname/$wrapper") || return undef;

    print WRAPPER "//\n// Generated automatically by leap-configure\n//\n\n";

    #
    # add defines for parameters
    #   TBD: Share this code with leap-configure

    print WRAPPER "// These are the parameters for the module\n";

    my @p = ();
    push(@p, $module->parameters());

    foreach my $p (@p) {
      my $pname = $p->name();
      my $pvalue = $p->value();

      if ($pname eq "SMART_SYNTH_BOUNDARY") {
          $usesmartsynthesisboundaries = $pvalue;
      }

      print WRAPPER "`define $pname $pvalue\n";
    }

    print WRAPPER "\n";
    print WRAPPER "// These are well-known/required leap modules\n";

    if ($usesmartsynthesisboundaries) {
      if ($isroot) {
        print WRAPPER "`include \"awb/provides/soft_connections_alg.bsh\"\n";
      } else {
        print WRAPPER "`include \"awb/provides/smart_synth_boundaries.bsh\"\n";
      }
      print WRAPPER "\n";
    }

    #
    # add includes for public sources
    #   Note: Can't just include 'provides' name since it bsc won't 
    #         find the correct instance of the file
    #

    print WRAPPER "// import non-synthesis public files\n";
    foreach my $file_root ($module->sources("BSV", "PUBLIC")) {
        print WRAPPER "`include \"$file_root\"\n";
    }
    print WRAPPER "\n";

    print WRAPPER "// import non-synthesis private files\n";
    foreach my $file_root ($module->sources("BSV", "PRIVATE")) {
        print WRAPPER "`include \"$file_root\"\n";
    }
    print WRAPPER "\n";

    if ($isroot) {
        print WRAPPER "\n";
        print WRAPPER "// Get defintion of TOP_LEVEL_WIRES\n";
        print WRAPPER "import physical_platform::*;\n";
        print WRAPPER "\n";
        print WRAPPER "(* synthesize *)\n";
        print WRAPPER "(* no_default_clock, no_default_reset *)\n";
        print WRAPPER "module ${module_name} (TOP_LEVEL_WIRES);\n";    
    } else {
        print WRAPPER "`ifndef CONNECTION_SIZES_KNOWN\n";
        print WRAPPER "// First pass to see how large the vectors should be\n";
        print WRAPPER "`define CON_RECV_${metatype} 100\n";
        print WRAPPER "`define CON_SEND_${metatype} 100\n";
        print WRAPPER "`define CON_RECV_MULTI_${metatype} 50\n";
        print WRAPPER "`define CON_SEND_MULTI_${metatype} 50\n";
        print WRAPPER "`define CHAINS_${metatype} 50\n";
        print WRAPPER "`else\n";
        print WRAPPER "// Real build pass.  Include file built dynamically.\n";
        print WRAPPER "`include \"${synth_name}_con_size.bsh\"\n";
        print WRAPPER "`endif\n";
        print WRAPPER "\n";
        print WRAPPER "(* synthesize *)\n";
	print WRAPPER "module ${module_name} (SOFT_SERVICES_SYNTHESIS_BOUNDARY#(`CON_RECV_${metatype}, `CON_SEND_${metatype}, `CON_RECV_MULTI_${metatype}, `CON_SEND_MULTI_${metatype}, `CHAINS_${metatype}));\n";    
    }
    print WRAPPER "\n";

    my @child_info_vars = ();
    print WRAPPER "    // instantiate own module\n";

    if ( ! $usesmartsynthesisboundaries ) {
      print WRAPPER "     let m <- $synth_id();\n";
    } else {
      if ($isroot) {
        print WRAPPER "    let m <- instantiateWithConnections($synth_id);\n";
      } else {
        print WRAPPER "    let m <- instantiateSmartBoundary($synth_id);\n";
      }
    }
    print WRAPPER "\n";

    print WRAPPER "    return m;\n";
    print WRAPPER "\n";

    print WRAPPER "endmodule\n";

    close(WRAPPER);
}

############################################################
# make_iface: Build interface files (RRR and dictionary)
#             in a separate tree.
#
sub make_iface {
    my $model = shift;

    my $template = Leap::Build::get_scons_root_template($model, "iface");
    return if (! defined($template));

    my $dir = Leap::Util::path_append($builddir, "iface");
    $status = system("mkdir -p " . $dir);

    my $replacements_r = Leap::Util::empty_hash_ref();

    Leap::Util::common_replacements($model, $replacements_r);
    note_builddir($replacements_r);

    Leap::Util::hash_set($replacements_r, '@DICT_SRCS@', "src/dict/dynamic_params.dic");
    Leap::Util::hash_set($replacements_r, '@ROOT_DIR_SW_INC@', "../sw/include");

    my $dict_src_dir = Leap::Util::path_append($dir, "src/dict");
    $status = system("mkdir -p " . $dict_src_dir);
    make_dictionary($model, $dict_src_dir, $replacements_r);

    my $rrr_src_dir = Leap::Util::path_append($dir, "src/rrr");
    $status = system("mkdir -p " . $rrr_src_dir);
    make_rrr($model, $rrr_src_dir, $replacements_r);

    ##
    ## Build the dynamic parameter dictionary
    ##
    my $params = Leap::Util::path_append($builddir, "iface/src/dict/dynamic_params.dic");
    unlink($params);
    open(PARAM, ">$params") or die("Failed to create $params");
    print PARAM "//\n";
    print PARAM "// Synthesized dynamic parameter manager\n";
    print PARAM "//\n";
    print PARAM "//   This file was created by " . basename($0) . "\n";
    print PARAM "//\n";
    print PARAM "\n";

    foreach my $param (sort keys(%dynamic_params)) {
        if ($dynamic_params{$param}[2] eq "UINT64") {
            print PARAM "def PARAMS." . uc($dynamic_params{$param}[0]) . "." . uc($param) . " \"" . $dynamic_params{$param}[3] . "\";\n";
        }
    }

    close(PARAM);

    my $scons = Leap::Util::path_append($builddir, "iface", "SConstruct");
    Leap::Templates::do_replacements($template, $scons, $replacements_r);
}

############################################################
# make_dictionary: Build the dictionary in a separate tree
#
sub make_dictionary {
    my $model = shift;
    my $dir = shift;
    my $replacements_r = shift;

    # gather other info recursively
    __make_dictionary($model->modelroot(), $dir, $replacements_r);
}

############################################################
# __make_dictionary: recursively build dictionary links
#
sub __make_dictionary {
    my $module = shift;
    my $dir = shift;
    my $replacements_r = shift;

    my $base_dir = $module->base_dir();

    # Link to dictionaries
    my @d = $module->sources("DICT", "*");
    foreach my $f (@d) {
        my $src = Asim::resolve(Leap::Util::path_append($base_dir,$f));

        if (! -e $src) {
          Leap::Util::WARN_AND_DIE("Module file $f does not exist in $base_dir");
        }
        
        # make src relative
        my $relsrc = File::Spec->abs2rel($src, $dir);
        $status = system("ln -f -s $relsrc $dir");

        # Add to list of sources
        Leap::Util::hash_append($replacements_r, " ", '@DICT_SRCS@', "src/dict/$f");
    }

    # recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
	__make_dictionary($child, $dir, $replacements_r);
    }
}

############################################################
# make_master_rrr_file: Make master list of RRR services
sub make_rrr {
    my $model = shift;
    my $dir = shift;
    my $replacements_r = shift;

    __make_rrr($model->modelroot(), $dir, "src/rrr", $replacements_r);
}

############################################################
# __get_rrr_files: Recursively get list of RRR files
sub __make_rrr {
    my $module = shift;
    my $parent_dir = shift;
    my $rel_dir = shift;
    my $replacements_r = shift;

    my $my_dir = Leap::Build::get_module_build_dir($module, $parent_dir);
    my $base_dir = $module->base_dir();

    $rel_dir = Leap::Build::get_module_build_dir($module, $rel_dir);

    # Link to dictionaries
    my @d = $module->sources("RRR", "*");
    foreach my $f (@d) {
        my $src = Asim::resolve(Leap::Util::path_append($base_dir, $f));

        if (! -e $src) {
          Leap::Util::WARN_AND_DIE("Module file $f does not exist in $base_dir");
        }
        
        # make src relative
        my $relsrc = File::Spec->abs2rel($src, $my_dir);
        system("mkdir -p $my_dir");
        system("ln -f -s $relsrc $my_dir");

        # Add to list of sources
        Leap::Util::hash_append($replacements_r, " ", '@RRR_SRCS@', "$rel_dir/$f");
    }

    # recurse
    Leap::Build::check_submodules_defined($module);
    foreach my $child ($module->submodules()) {
        __make_rrr($child, $my_dir, $rel_dir, $replacements_r);
    }
}


__END__

=head1 NAME

leap-configure - Program to configure/build/run an awb-based design

=head1 SYNOPSIS

     % leap-configure <COMMAND> [option]... [argument]...

=head1 DESCRIPTION

The leap-configure command allows a user working on an awb(1)-based
design to configure, build and run the design. The basic input to most
commands is a model description (.apm file) and if the command
involves setting up or running a benchmark than a benchmark file (.cfg
file) is also needed.

This command is basically the hybrid hardware/software design analog
of the amc(1) command, which is used for purely software-based
performance models.

Note that leap-configure is primarily an internal command, and its 
direct use is discouraged in favor it having it invoked indirectly
through awb-shell.


=head1 SWITCHES

The following command line switches are currently supported and can
be applied to any command:

=over 4 

=item --[no]silent

Specifies whether to be silent or to not, i.e., to print when the run
is done. Default is NOT to be silent.

=item --[no]debug

Specifies that extra debuging information should be printed. The [no]
prefix reverses the sense of the command. Default is NOT to debug.

=back

=head1 COMMANDS

The following commands are supported:

=over 4

=item B<configure --model E<lt>model-fileE<gt> [option]...>

Configure the specified model by traversing the module hierarchy for
the selected model and creating a standard build tree for it. Symbolic
links are created pointing at the original source files for the
modules and Makefile and/or Sconstruct files are created along with
other synthesized source files.

Options:

=over 4 

=item --model <model-file>

Specifies the .apm describing model to work on.

Specification may be in the awb workspace uniondir form, where a
search based at the root of each of the packages in the workspace will
be made for the file if a relative path name is given.

=item --builddir <directory>

Specifies the directory to contain the configured design. This switch
is optional and a default location is calculated based on the model
file (see explanation in FILES section below). In any case, if the
directory does not exist it will be created.

=item --[no]private

Specifies whether private bsv files are included in the include files. Default is true.

=item --[no]public

Specifies whether public bsv files are included in the include files. Default is true.

=back

=item B<nuke --model E<lt>model-fileE<gt> [option]...>

Delete the build tree created by configure. In most cases, the
benchmarks associated with that build will be deleted as well.

Benchmark deletion occurs if the build directory is named pm/. In this
case the parent directory of pm/ and all its contents will be deleted
recursively, i.e., the pm/ directory and all peers of the pm/
directory.

Options:

=over 4 

=item --model <model-file>

Specifies the .apm describing model to work on.

=item --builddir <directory>

Specifies the directory containing the configured design as specified
in the B<configure> command. This switch is necessary if it was specified
in the prior B<configure> command.

=back

=item B<build --model E<lt>model-fileE<gt> [option]...>

Builds the specified model. Essentially invokes make/scons in
the appropriate directory with the appropriate switches.

Options:

=over 4 

=item --model <model-file>

See the B<configure> command.

=item --builddir <directory>

Specifies the directory containing the configured design as specified
in the B<configure> command. This switch is necessary if it was specified
in the prior B<configure> command.

=item --buildopt <build-options>

Specifies the options to pass on to the build.

=back

=item B<setup --model E<lt>model-fileE<gt> [--benchmark E<lt>benchmark-fileE<gt>] [option]...>

Sets up the specified benchmark on the specified model. Creates the run directory and
some helper files, and then invokes the configuration script specified in the
benchmark's descrption (.cfg) file.

Options:

=over 4 

=item --model <model-file>

See the B<configure> command.

=item --builddir <directory>

Specifies the directory containing the configured design as specified
in the B<configure> command. This switch is necessary if it was specified
in the prior B<configure> command.

=item --benchmark <benchmark-file>

Specifies the file describing the benchmark.

Specification may be in the awb workspace uniondir form, where a
search based at the root of each of the packages in the workspace will
be made for the file if a relative path name is given.

If the model has been configured with a default benchmark, then that
benchmark will be used if the --benchmark switch is omitted.

=item --rundir <directory>

Specifies the directory to contain the set up benchmark. This switch
is optional and a default location is calculated based on the model
file (see explanation in FILES section below). In any case, if the
directory does not exist it will be created.

=back

=item B<run --model E<lt>model-fileE<gt> [--benchmark E<lt>benchmark-fileE<gt>] [option]...>

Runs the specified benchmark on the specified model. Does little more than invoke
./run in the benchmark directory.

Options:

=over 4 

=item --model <model-file>

See the B<configure> command.

=item --benchmark <benchmark-file>

See the B<setup> command.

=item --rundir <directory>

Specifies the directory containing the set up benchmark as specified
in the B<setup> command. This switch is necessary if it was specified
in the prior B<setup> command.

=item --runopt <run-options>

Specifies the options to pass on to the run.

=back

=item B<help>

Get this help information.

=item B<options>

List the awb.config/asimrc options for this program.


=back

=head1 OPERATION

TBD

=head1 FILES

The default model build directory and benchmark run directory names
are calculated using the following format:

   <workspace>/build/default/<model>/pm/

   <workspace>/build/default/<model>/bm/<benchmark>/

where <workspace> is the current workspace, <model> is the filename of
the .apm file (excluding the extension) and <benchmark> is the filename
of the .cfg file (excluding the extension).

   
=head1 EXAMPLES

To run configure and build a model and then setup and run a benchmark:

    % leap-configure configure --model=config/pm/.../foo.apm

    % leap-configure build --model=config/pm/.../foo.apm

    % leap-configure setup --model=config/pm/.../foo.apm --benchmark=config/bm/.../bar.cfg

    % leap-configure run --model=config/pm/.../foo.apm --benchmark=config/bm/.../bar.cfg

Note this could also have been done through the use of awb-shell(1).

=head1 ENVIRONMENT VARIABLES

None

=head1 OPTIONS

Defaults for many of the leap-configure switches can be set in the
Asim rcfiles.  Like serveral awb-releated programs leap-configure
looks for these options first in the user's <workspace>/awb.config
file, then in the user's ~/.asim/asimrc file, and finally in the
system's <installdir>/etc/asim/asimrc file.

A listing of the available options that can be set can be obtained
with:

        % leap-configure options

=head1 BUGS

In addtion to a desperately needed code cleanup, the --silent switch
seems silly and the --relative switch seems unused.

Passing options via --buildopts and --runopts to the build and run
that contain quotes is tricky...

Ideally this command and amc(1) should be combined into a single
command, awb-configure(1), that can configure all software and/or
hardware designs.

=head1 AUTHORS

Martha Mercaldi and extended by many others.

=cut

