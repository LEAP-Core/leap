#!/usr/bin/env perl
# -*- perl -*-

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  
#


use File::Basename;
use Getopt::Long;

use Asim;
use AsimShell;

use Leap;

#
# Turn on warnings
#
$^W = 1;



############################################################
# handle command line

my $status;

my $help = 0;
my $debug = 0;
my $dynsize = 0;

$status = GetOptions( "debug!"     => \$debug,
                      "help!"      => \$help,
                      "softservices!" => \$softservices,
                      "dynsize!"   => \$dynsize,
		      );

my $prog = basename($0);

if (!$status) {
    print STDERR "$prog: Illegal argument, try '$prog --help'\n";
    exit 0;
}

if ($help) {
    system "perldoc $0";
    exit 0;
}

############################################################
# main body of script

my $modelfile = shift;
my $targetfile = shift;

Asim::init()
    || die("Unable to initialize Asim::\n");

if ($dynsize) {
    create_dynsize_bsh($targetfile, $modelfile);
}
else {
    create_surrogate($modelfile, $targetfile);
}

exit 0;


############################################################
# 

sub create_dynsize_bsh {
    my $tgt_file = shift;
    my $log_file = shift;

    my $metatype = basename($log_file);
    $metatype =~ s/_Wrapper\.log$//;

    my @conns = parse_dangling_connections($log_file);
    my $sends = 0;
    my $recvs = 0;
    foreach my $conn_r (@conns) {
        if ($conn_r->[0] eq "Send") {
            $sends += 1;
        } elsif ($conn_r->[0] eq "Rec") {
            $recvs += 1;
        } else {
            DIE("Unrecognized type of dangling connection: $1\n");
        }     
    }

    open(SIZES, "> $tgt_file") or die("Failed to open $tgt_file for writing");
    print SIZES "//\n";
    print SIZES "// Dynamic connection sizes, generated by leap-connect --dynsize\n";
    print SIZES "//\n\n";
    print SIZES "`ifndef CON_RECV_${metatype}\n";
    print SIZES "`define CON_RECV_${metatype} ${recvs}\n";
    print SIZES "`endif\n\n";
    print SIZES "`ifndef CON_SEND_${metatype}\n";
    print SIZES "`define CON_SEND_${metatype} ${sends}\n";
    print SIZES "`endif\n";
    close(SIZES);
}

############################################################
# 

sub create_surrogate {
    my $modelfile = shift;
    my $filename = shift;

    my $metatype = basename($filename);
    $metatype =~ s/\.bsv//;

    my $model = Asim::Model->new($modelfile);

    if (defined(&Asim::Model::embed_submodels)) {
      print "Using Asim::Model embed_submodels\n";
      $model->embed_submodels();
    } else {
      print "Using Asim::Model without embed_submodels\n";
    }       

    my $root = $model->modelroot();

    my $module = $root->find_module_providing($metatype);

    my $synth_id = Leap::Build::get_synthesis_boundary_name($module);
    my $synth_instances = Leap::Build::synthesis_instances($module);

    CORE::open(SURROGATE, "> $filename") or die("Failed to open $filename for writing");
    print SURROGATE "//\n";
    print SURROGATE "// Dynamic connection surrogate, generated by leap-connect\n";
    print SURROGATE "//\n\n";
    print SURROGATE "// Surrogate for $metatype\n";

    print SURROGATE "\n";
    print SURROGATE "// These are well-known/required leap modules\n";
    print SURROGATE "`include \"asim/provides/smart_synth_boundaries.bsh\"\n";
    print SURROGATE "`include \"asim/provides/soft_connections.bsh\"\n";
    print SURROGATE "\n";

    print SURROGATE "// Sizes from wrapper and module imports\n";
    if ($synth_instances == 0) {
        print SURROGATE "`include \"${metatype}/${metatype}_Wrapper_con_size.bsh\"\n";
        print SURROGATE "import " . make_wrapper_name($metatype) . "::*;\n\n";
    }
    else {
        for (my $i = 0; $i < $synth_instances; $i++) {
            print SURROGATE "`include \"${metatype}/${metatype}_${i}_Wrapper_con_size.bsh\"\n";
            print SURROGATE "import " . Leap::Build::make_instance_wrapper_name($metatype, $i) . "::*;\n\n";
        }
    }

    print SURROGATE "module [Connected_Module] $synth_id ();\n\n";

    if ($synth_instances == 0) {
        my $logfile_name = logfile_name($filename, $metatype);
        add_connections(SURROGATE, $logfile_name, $metatype);
    }
    else {
        for (my $i = 0; $i < $synth_instances; $i++) {
            my $logfile_name = instance_logfile_name($filename, $metatype, $i);
            add_connections(SURROGATE, $logfile_name, $metatype . "_$i");
        }
    }

    print SURROGATE "endmodule\n";

    ##
    ## Recent versions of SCons are too clever.  They don't rebuild the wrapper
    ## generated here if the wrapper doesn't change, even when the underlying
    ## code changes.  This is technically fine, but Bluespec notes the timestamps
    ## and complains.  Force a rebuild when leap-connect is run by adding a
    ## timestamp.  We could try to be more clever and use MD5 sums of the
    ## lower level compiled files, but they appear to have timestamps too.
    ##
    print SURROGATE "\n//" . localtime() . "\n";

    CORE::close(SURROGATE);
}

sub add_connections {
    my $of = shift;
    my $logfile_name = shift;
    my $metatype = shift;

    my $wrap_var = "wrap_" . $metatype;
    my $mk_wrapper = make_module_name(make_wrapper_name($metatype));

    # Soft services must route through the model clock...
    if($softservices) {
	print $of "    // 1.  obtain model clock from context\n";
        print $of "    SoftServicesContext ctxt <- getContext();\n";
        print $of "    LOGICAL_CLOCK_INFO model_clock = getIt(ctxt);\n";
       	print $of "    // 2. instantiate wrapper\n";
	print $of "    SoftServicesSynthesisInterface#(`CON_RECV_${metatype}, `CON_SEND_${metatype}) $wrap_var <- $mk_wrapper(clocked_by model_clock.clk, reset_by model_clock.rst);\n";

    } 
    else {
	print $of "    // 1. instantiate wrapper\n";
	print $of "    WithConnections#(`CON_RECV_${metatype}, `CON_SEND_${metatype}) $wrap_var <- $mk_wrapper();\n";
   }
    print $of "    // 2. log sends & recvs\n";
    my @conns = parse_dangling_connections($logfile_name);
    my @sends_exprs = ();
    my @recvs_exprs = ();

    
     foreach my $conn_r (@conns) {
	my $expr = "";
        if($softservices) {
            $expr = "tuple4(\"" . $conn_r->[3] . "\", \"" . $conn_r->[1] . "\", \"" . $conn_r->[4] . "\", "  . $conn_r->[2] . ")";
	} else {
	    $expr = "tuple3(\"" . $conn_r->[3] . "\", \"" . $conn_r->[1] . "\", " . $conn_r->[2] . ")";
	}
        if ($conn_r->[0] eq "Send") {
            push (@sends_exprs, $expr);
        } elsif ($conn_r->[0] eq "Rec") {
            push (@recvs_exprs, $expr);
        } else {
            DIE("Unrecognized type of dangling connection: $1\n");
        }     
    }

    my $sends_var = "dsends_" . $metatype;
    my $recvs_var = "drecvs_" . $metatype;

    my $sends_cons = get_cons_expr(@sends_exprs);
    my $recvs_cons = get_cons_expr(@recvs_exprs);

    print $of "    let $sends_var = $sends_cons;\n";
    print $of "    let $recvs_var = $recvs_cons;\n";

    print $of "    addConnections($wrap_var, $sends_var, $recvs_var);\n\n";
}


############################################################
# 
sub logfile_name {
    my $ofile_name = shift;
    my $metatype = shift;
  
    return dirname($ofile_name) .
        "/${metatype}/.bsc/" .
        make_wrapper_name($metatype) . ".log";
}

############################################################
# 
sub instance_logfile_name {
    my $ofile_name = shift;
    my $metatype = shift;
    my $instance = shift;
  
    return dirname($ofile_name) .
        "/${metatype}/.bsc/" .
        Leap::Build::make_instance_wrapper_name($metatype, $instance) . ".log";
}

############################################################
# 
sub make_wrapper_name {
    my $name = shift;
  
    return $name . "_Wrapper";
}

############################################################
# 
sub make_module_name {
    my $name = shift;
  
    return "mk_" . $name;
}


##########################################################
# 
sub get_module_build_dir {
    my $target = shift;
    my $current = shift;
    my $path = shift;

    my $tmp = $target->provides();
    my $tmp2 = $current->provides();
#    print "SEARCHING FOR $tmp FROM $tmp2\n";

    if ( Leap::Build::is_synthesis_boundary($current) ) {
	$path = $path . "/" . $current->provides();
	if ($current->issame($target)) {
#	    print "RETURNING PATH: $path\n";
	    return $path;
	}
    }

    foreach my $submodule ($current->submodules()) {
	my $tmp3 = $submodule->provides();
#	print "   CHILD $tmp3\n";
	my $res = get_module_build_dir($target,$submodule,$path);
	if ($res) {
#	    print "SUCCESS\n";
	    return $res;		    
	}
    }
    return "";
#    print "DONE\n";
#    DIE("Control should never reach here.\n");
}

############################################################
# 
sub get_cons_expr {
    my @vars = @_;

    if ($#vars == -1) {
	return "List::nil";
    }

    return "cons(" . $vars[0] . ", " . get_cons_expr(@vars[1 .. $#vars]) . ")";
}


############################################################
# 
sub parse_dangling_connections {
    my $log_file = shift;

#Compilation message: "HASim.bsv", line 518, column 5: Dangling Send {<type>} [0]: mem_imem_req
#Compilation message: "HASim.bsv", line 528, column 5: Dangling Rec {<type>} [0]: mem_imem_resp

    #print "parsing: $log_file\n";
    my @conns = ();
    CORE::open(LOG, "< $log_file") || return undef;
    while (my $line = <LOG>) {
        if ($line =~ /^Compilation message: .*: Dangling /) {
            if($softservices) {
	        if ($line =~ /.*Dangling (\w+) {(.*)} \[(\d+)\]:(\w+):(\w+)/) {                   
		    my @connection = ($1,$2,$3,$4,$5);
		    push(@conns, [@connection]);
		}
		else {
		    DIE("SoftServices: Malformed dangling connection message");
		}
	    } else { #Backwards compatibility
	        if ($line =~ /.*Dangling (\w+) {(.*)} \[(\d+)\]: (\w+)/) {
		    my @connection = ($1,$2,$3,$4);
		    push(@conns, [@connection]);
		}
		else {
		    DIE("Malformed dangling connection message");
		}
	    }
        }
    }
    CORE::close(LOG);

    return @conns;
}

sub WARN {
    my $msg = shift;
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
    print STDERR "$filename: ($subroutine) [called from ln $line]: $msg\n";
}

sub DIE {
    my $msg = shift;
    WARN($msg);
    die;
}
