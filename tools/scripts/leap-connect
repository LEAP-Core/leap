#!/usr/bin/env perl
# -*- perl -*-

# *****************************************************************
# *                                                               *
# *   Copyright (c) (Fill in here)                                *
# *                                                               *
# *****************************************************************

#
# Author:  
#


use File::Basename;
use Getopt::Long;

use Asim;
use AsimShell;

use Leap;

#
# Turn on warnings
#
$^W = 1;



############################################################
# handle command line

my $status;

my $help = 0;
my $debug = 0;
my $dynsize = 0;
my $genDummyFile = 0;

$status = GetOptions( "debug!"     => \$debug,
                      "help!"      => \$help,
                      "softservices!" => \$softservices,
                      "dynsize!"   => \$dynsize, 
                      "alternative_logfile=s"  => \$alternative_logfile,
                      "dummy"      => \$genDummyFile
		      );

my $prog = basename($0);

if (!$status) {
    print STDERR "$prog: Illegal argument, try '$prog --help'\n";
    exit 0;
}

if ($help) {
    system "perldoc $0";
    exit 0;
}

############################################################
# main body of script

Asim::init()
    || die("Unable to initialize Asim::\n");

if ($dynsize) {
    my $modelfile = shift;
    my $targetfile = shift;
    create_dynsize_bsh($targetfile, $modelfile);
} 
else {
    my $modelfile = shift;
    my $targetfile = shift;
    create_surrogate($modelfile, $targetfile);
}

exit 0;


############################################################
# 

sub create_dynsize_bsh {
    my $tgt_file = shift;
    my $log_file = shift;

    my $metatype = basename($log_file);
    $metatype =~ s/_Wrapper\.log$//;

    my $sends = 0;
    my $recvs = 0;
    my $send_multis = 0;
    my $recv_multis = 0;
    my $chains = 0;
    my $total_conns = 0;

    if (! $genDummyFile) {
        my @conns = parse_dangling_connections($log_file);
        $total_conns = $#conns + 1;

        if ($softservices) {
            for (my $i = 0; $i < scalar(@conns); $i++) {
                if ($conns[$i]->{"sc_type"} eq "Send") {
                    $sends += 1;
                } elsif ($conns[$i]->{"sc_type"} eq "Recv") {
                    $recvs += 1;
                } elsif ($conns[$i]->{"sc_type"} eq "RecvMulti") {
                    $recv_multis += 1;
                } elsif ($conns[$i]->{"sc_type"} eq "SendMulti") {
                    $send_multis += 1;
                } elsif ($conns[$i]->{"sc_type"} eq "Chain") {
                    $chains += 1;
                } else {
                    DIE("Soft Serices: Unrecognized type of dangling connection: $1\n");
                }
            }
        } else {
            foreach $conn_r (@conns) {
                if ($conn_r->[0] eq "Send") {
                    $sends += 1;
                } elsif ($conn_r->[0] eq "Rec") {
                    $recvs += 1;
                } else {
                    DIE("Unrecognized type of dangling connection: $1\n");
                }
            }
        }

        ## Don't allow the total number of connections to be 0.  If 0 the
        ## entire synthesis boundary may be optimized away and symbols
        ## defined in Xilinx configuration files may then be missing.
        ## (E.g. CLK)
        if ($total_conns == 0) {
            $recvs += 1;
        }
    }

    open(SIZES, "> $tgt_file") or die("Failed to open $tgt_file for writing");
    print SIZES "//\n";
    print SIZES "// Dynamic connection sizes, generated by leap-connect --dynsize\n";
    print SIZES "//\n\n";
    print SIZES "`ifndef CON_RECV_${metatype}\n";
    print SIZES "`define CON_RECV_${metatype} ${recvs}\n";
    print SIZES "`endif\n\n";
    print SIZES "`ifndef CON_SEND_${metatype}\n";
    print SIZES "`define CON_SEND_${metatype} ${sends}\n";
    print SIZES "`endif\n";
    if ($softservices) {
        print SIZES "`ifndef CON_RECV_MULTI_${metatype}\n";
        print SIZES "`define CON_RECV_MULTI_${metatype} ${recv_multis}\n";
        print SIZES "`endif\n\n";

        print SIZES "`ifndef CHAINS_${metatype}\n";
        print SIZES "`define CHAINS_${metatype} ${chains}\n";
        print SIZES "`endif\n\n";

        print SIZES "`ifndef CON_SEND_MULTI_${metatype}\n";
        print SIZES "`define CON_SEND_MULTI_${metatype} ${send_multis}\n";
        print SIZES "`endif\n";    
    } else {
        print SIZES "`ifndef CON_RECV_MULTI_${metatype}\n";
        print SIZES "`define CON_RECV_MULTI_${metatype} 0\n";
        print SIZES "`endif\n\n";
        print SIZES "`ifndef CON_SEND_MULTI_${metatype}\n";
        print SIZES "`define CON_SEND_MULTI_${metatype} 0\n";
        print SIZES "`endif\n";
        print SIZES "`ifndef CHAINS_${metatype}\n";
        print SIZES "`define CHAINS_${metatype} 0\n";
        print SIZES "`endif\n\n";
    }
    close(SIZES);
}

############################################################
# 

sub create_surrogate {
    my $modelfile = shift;
    my $filename = shift;

    my $metatype = basename($filename);
    $metatype =~ s/\.bsv$//;
    $metatype =~ s/_synth$//;

    my $model = Asim::Model->new($modelfile);

    if (defined(&Asim::Model::embed_submodels)) {
        print "Using Asim::Model embed_submodels\n" if (! $genDummyFile);
        $model->embed_submodels();
    } else {
        print "Using Asim::Model without embed_submodels\n" if (! $genDummyFile);
    }       

    my $root = $model->modelroot();

    my $module = $root->find_module_providing($metatype);
    my $synth_id = Leap::Build::get_synthesis_boundary_name($module);
    # we need to derive this from out logfile XXX
    my $synth_instances = Leap::Build::synthesis_instances($module);

    CORE::open(SURROGATE, "> $filename") or die("Failed to open $filename for writing");
    print SURROGATE "//\n";
    print SURROGATE "// Dynamic connection surrogate, generated by leap-connect\n";
    print SURROGATE "//\n\n";
    print SURROGATE "// Surrogate for $metatype\n";

    print SURROGATE "\n";
    print SURROGATE "// These are well-known/required leap modules\n";
    print SURROGATE "`include \"asim/provides/smart_synth_boundaries.bsh\"\n";
    print SURROGATE "`include \"asim/provides/soft_connections.bsh\"\n";
    print SURROGATE "\n";

    print SURROGATE "// Sizes from wrapper and module imports\n";
    if ($synth_instances == 0) {
        print SURROGATE "`include \"${metatype}/${metatype}_Wrapper_con_size.bsh\"\n";
        print SURROGATE "import " . make_wrapper_name($metatype) . "::*;\n\n";
    }
    else {
        for (my $i = 0; $i < $synth_instances; $i++) {
            print SURROGATE "`include \"${metatype}/${metatype}_${i}_Wrapper_con_size.bsh\"\n";
            print SURROGATE "import " . Leap::Build::make_instance_wrapper_name($metatype, $i) . "::*;\n\n";
        }
    }

    print SURROGATE "module [Connected_Module] $synth_id ();\n\n";

    if ($synth_instances == 0) {
        if(defined($alternative_logfile)) {
            add_connections(SURROGATE, $alternative_logfile, $metatype);
	} 
        else {
            my $logfile_name = logfile_name($filename, $metatype);
            add_connections(SURROGATE, $logfile_name, $metatype);
	}
    }
    else {
        for (my $i = 0; $i < $synth_instances; $i++) {
            my $logfile_name = instance_logfile_name($filename, $metatype, $i);
            add_connections(SURROGATE, $logfile_name, $metatype . "_$i");
        }
    }

    print SURROGATE "endmodule\n";

    ##
    ## Recent versions of SCons are too clever.  They don't rebuild the wrapper
    ## generated here if the wrapper doesn't change, even when the underlying
    ## code changes.  This is technically fine, but Bluespec notes the timestamps
    ## and complains.  Force a rebuild when leap-connect is run by adding a
    ## timestamp.  We could try to be more clever and use MD5 sums of the
    ## lower level compiled files, but they appear to have timestamps too.
    ##
    print SURROGATE "\n//" . localtime() . "\n";

    CORE::close(SURROGATE);
}

sub add_connections {
    my $of = shift;
    my $logfile_name = shift;
    my $metatype = shift;

    if ($genDummyFile) {
        return;
    }

    my $wrap_var = "wrap_" . $metatype;
    my $mk_wrapper = make_module_name(make_wrapper_name($metatype));

    # Soft services must route through the model clock...
    if ($softservices) {
	print $of "    // Obtain model clock from context\n";
        print $of "    LOGICAL_CLOCK_INFO model_clock <- getContext();\n";
       	print $of "    // Instantiate wrapper using the correct clock.\n";
	print $of "    SOFT_SERVICES_SYNTHESIS_BOUNDARY#(`CON_RECV_${metatype}, `CON_SEND_${metatype}, `CON_RECV_MULTI_${metatype}, `CON_SEND_MULTI_${metatype}, `CHAINS_${metatype}) $wrap_var <- liftModule($mk_wrapper(clocked_by model_clock.clk, reset_by model_clock.rst));\n";
        print $of "    messageM(\"Instantiating ${metatype} Stub\");\n";
        print $of "    // Begin: Register Soft Connections\n";
        print $of "    let connections = tpl_1($wrap_var.services);\n";
        print $of " // logfile: $logfile_name\n";
        my @conns = parse_dangling_connections($logfile_name);
        for (my $i = 0; $i < scalar(@conns); $i++) {
            my $conname = $conns[$i]->{"name"};
            my $contype = $conns[$i]->{"type"};
            my $conidx  = $conns[$i]->{"idx"};
            my $conplat = $conns[$i]->{"platform"};
            my $conopt  = $conns[$i]->{"optional"};
            my $conbitwidth  = $conns[$i]->{"bitwidth"};
            my $boundaryname  = $conns[$i]->{"boundaryname"};
            my $chainrootboundaryname  = $conns[$i]->{"chainrootboundaryname"};

            if ($conns[$i]->{"sc_type"} eq "Send") {
                print $of "    registerSend(LOGICAL_SEND_INFO { logicalName: \"$conname\", logicalType: \"$contype\", computePlatform: \"$conplat\", optional: $conopt, outgoing: connections.outgoing[$conidx], bitWidth: $conbitwidth, moduleName: \"$boundaryname\"});\n";
            } elsif ($conns[$i]->{"sc_type"} eq "Recv") {
                print $of "    registerRecv(LOGICAL_RECV_INFO { logicalName: \"$conname\", logicalType: \"$contype\", computePlatform: \"$conplat\", optional: $conopt, incoming: connections.incoming[$conidx],  bitWidth: $conbitwidth, moduleName: \"$boundaryname\"});\n";
            } elsif ($conns[$i]->{"sc_type"} eq "SendMulti") {
                print $of "    registerSendMulti(LOGICAL_SEND_MULTI_INFO { logicalName: \"$conname\", logicalType: \"$contype\", computePlatform: \"$conplat\", optional: $conopt, outgoing: connections.outgoingMultis[$conidx] });\n";
            } elsif ($conns[$i]->{"sc_type"} eq "RecvMulti") {
                print $of "    registerRecvMulti(LOGICAL_RECV_MULTI_INFO { logicalName: \"$conname\", logicalType: \"$contype\", computePlatform: \"$conplat\", optional: $conopt, incoming: connections.incomingMultis[$conidx] });\n";
	    } elsif ($conns[$i]->{"sc_type"} eq "Chain") {
                print $of "    registerChain(LOGICAL_CHAIN_INFO { logicalName: \"$conname\", logicalType: \"$contype\", computePlatform: \"$conplat\", incoming: connections.chains[$conidx].incoming, outgoing: connections.chains[$conidx].outgoing,  bitWidth: $conbitwidth, moduleNameIncoming: \"$boundaryname\", moduleNameOutgoing: \"$chainrootboundaryname\" });\n";
            }

        }
        #print $of "    // Backwards Compatability: Connection Chains\n";
        #print $of "    for (Integer x = 0; x < valueof(CON_NUM_CHAINS); x = x + 1)\n";
        #print $of "    begin\n";
        #print $of "        let info =\n";
        #print $of "            LOGICAL_CHAIN_INFO\n";
        #print $of "            {\n";
        #print $of "                logicalIdx: x,\n";
        #print $of "                logicalType: \"\",\n";
        #print $of "                incoming: connections.chains[x].incoming,\n";
        #print $of "                outgoing: connections.chains[x].outgoing\n";
        #print $of "            };\n";
        #print $of "        registerChain(info);\n";
        #print $of "    end\n";
        print $of "    // End: Register Soft Connections\n";

    } 
    else {
	print $of "    // 1. instantiate wrapper\n";
	print $of "    WithConnections#(`CON_RECV_${metatype}, `CON_SEND_${metatype}) $wrap_var <- $mk_wrapper();\n";
        print $of "    // 2. log sends & recvs\n";
        my @conns = parse_dangling_connections($logfile_name);
        my @sends_exprs = ();
        my @recvs_exprs = ();

        foreach my $conn_r (@conns) {
	    my $expr = "tuple3(\"" . $conn_r->[3] . "\", \"" . $conn_r->[1] . "\", " . $conn_r->[2] . ")";
            if ($conn_r->[0] eq "Send") {
                push (@sends_exprs, $expr);
            } elsif ($conn_r->[0] eq "Rec") {
                push (@recvs_exprs, $expr);
            } else {
                DIE("Unrecognized type of dangling connection: $1\n");
            }     
        }

        my $sends_var = "dsends_" . $metatype;
        my $recvs_var = "drecvs_" . $metatype;

        my $sends_cons = get_cons_expr(@sends_exprs);
        my $recvs_cons = get_cons_expr(@recvs_exprs);

        print $of "    let $sends_var = $sends_cons;\n";
        print $of "    let $recvs_var = $recvs_cons;\n";

        print $of "    addConnections($wrap_var, $sends_var, $recvs_var);\n\n";
    }
}


############################################################
# 
sub logfile_name {
    my $ofile_name = shift;
    my $metatype = shift;
  
    return dirname($ofile_name) .
        "/${metatype}/.bsc/" .
        make_wrapper_name($metatype) . ".log";
}

############################################################
# 
sub instance_logfile_name {
    my $ofile_name = shift;
    my $metatype = shift;
    my $instance = shift;
  
    return dirname($ofile_name) .
        "/${metatype}/.bsc/" .
        Leap::Build::make_instance_wrapper_name($metatype, $instance) . ".log";
}

############################################################
# 
sub make_wrapper_name {
    my $name = shift;
  
    return $name . "_Wrapper";
}

############################################################
# 
sub make_module_name {
    my $name = shift;
  
    return "mk_" . $name;
}


##########################################################
# 
sub get_module_build_dir {
    my $target = shift;
    my $current = shift;
    my $path = shift;

    my $tmp = $target->provides();
    my $tmp2 = $current->provides();
#    print "SEARCHING FOR $tmp FROM $tmp2\n";

    if ( Leap::Build::is_synthesis_boundary($current) ) {
	$path = $path . "/" . $current->provides();
	if ($current->issame($target)) {
#	    print "RETURNING PATH: $path\n";
	    return $path;
	}
    }

    foreach my $submodule ($current->submodules()) {
	my $tmp3 = $submodule->provides();
#	print "   CHILD $tmp3\n";
	my $res = get_module_build_dir($target,$submodule,$path);
	if ($res) {
#	    print "SUCCESS\n";
	    return $res;		    
	}
    }
    return "";
#    print "DONE\n";
#    DIE("Control should never reach here.\n");
}

############################################################
# 
sub get_cons_expr {
    my @vars = @_;

    if ($#vars == -1) {
	return "List::nil";
    }

    return "cons(" . $vars[0] . ", " . get_cons_expr(@vars[1 .. $#vars]) . ")";
}


############################################################
# 
sub parse_dangling_connections {
    my $log_file = shift;

#Compilation message: "HASim.bsv", line 518, column 5: Dangling Send {<type>} [0]: mem_imem_req
#Compilation message: "HASim.bsv", line 528, column 5: Dangling Rec {<type>} [0]: mem_imem_resp

    #print "parsing: $log_file\n";
    my @conns = ();
    my $line_count = 0;
    CORE::open(LOG, "< $log_file") || return undef;
    while (my $line = <LOG>) {
	$line_count = $line_count + 1;
        if ($line =~ /^Compilation message: .*: Dangling /) {
            if ($softservices) {
	        if ($line =~ /.*Dangling (\w+) {(.*)} \[(\d+)\]:(\w+):(\w+):(\w+):(\d+):(\w+):(\w+)/) {
		    my %connection = (
                        sc_type => $1,
                        name => $4,
                        type => $2,
                        idx => $3,
                        platform => $5,
                        optional => $6, 
                        bitwidth => $7,
                        boundaryname => $8,
                        chainrootboundaryname => $9
                    );
		    push(@conns, \%connection);
		}
		else {
		    DIE("Soft Services: Malformed dangling connection message $logfile line $line_count\n");
		}
	    } else { #Backwards compatibility
	        if ($line =~ /.*Dangling (\w+) {(.*)} \[(\d+)\]: (\w+)/) {
		    my @connection = ($1,$2,$3,$4);
		    push(@conns, [@connection]);
		}
		else {
		    DIE("Malformed dangling connection message $logfile line $line_count");
		}
	    }
        }
    }
    CORE::close(LOG);

    return @conns;
}


sub WARN {
    my $msg = shift;
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
    print STDERR "$filename: ($subroutine) [called from ln $line]: $msg\n";
}

sub DIE {
    my $msg = shift;
    WARN($msg);
    die;
}
