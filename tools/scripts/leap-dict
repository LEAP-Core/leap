#!/usr/bin/env perl
# -*- perl -*-

#
# Copyright (C) 2008 Intel Corporation
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# 
#

#
# Author: Michael Adler
#

use strict;
use Getopt::Long;
use IO::File;
use File::Basename;
use POSIX qw(ceil floor);

use Leap::DictBuilder;
use Leap::Build;
# use Data::Dumper;

#
# Turn on warnings
#
$^W = 1;

my $root;

# Debugging info
my $progName = 'leap-dict';
my $line = 0;
my $fName = '';

# Options
my $help = 0;
my $queryModules = 0;
my $tgtHwDir = '';
my $tgtIncDir = '';
my $srcIncDirs = '';

sub Error($) {
    my $msg = shift;
    print STDERR "${progName}: ${fName}:${line}, $msg\n";
    exit(1);
}

sub Usage($) {
    my $status = shift;

    print STDERR "Usage: $0 [--querymodules] [--tgt-inc <dir>] [--tgt-hw <dir>] <input files>\n";
    print STDERR "  Emit C or Bluespec data dictionaries derived from input files.\n\n";
    print STDERR "  --querymodules:  Just print the module names described in the input\n";
    print STDERR "                   files and exit.\n";
    print STDERR "  --tgt-inc <dir>: Target directory for include files.\n";
    print STDERR "  --tgt-hw  <dir>: Target directory for hw (BSV) files.\n";
    print STDERR "  --src-inc <dir>: Colon separated directory list, passed to CPP for parsing input files\n";
    exit($status);
}


###########################################################################
##
## Output file emitters
##
###########################################################################

##
## EmitHeader --
##   Emit the common header of bsh and h files.
##
sub EmitHeader($) {
    my $of = shift;

    print $of "//\n";
    print $of "// *** DO NOT EDIT ***\n";
    print $of "//\n";
    print $of "// This file is generated by $progName\n";
    print $of "//\n\n";
}


##
## EmitEnumValues --
##   Emit the dictionary name to value mappings.  This code is used by both
##   EmitH and EmitBSH.
##
sub EmitEnumValues($$$$) {
    my $of = shift;
    my $m = shift;
    my $format = shift;
    my $dict = shift;

    my $base_idx = $dict->GetBaseIdx();
    my $idx = $base_idx;
    foreach my $n ($dict->GetSortedEntries()) {
        printf $of $format, $m, $n, $idx;
        $idx += 1;
    }

    printf $of "\n";
    printf $of $format, $m, '_BASE', $base_idx;
    printf $of $format, $m, '_NENTRIES', $idx - $base_idx;
    printf $of $format, $m, '_NSUBGROUPS', $dict->GetNumDictionariesInTree() - 1;

    if ($idx == -1) {
        $idx = 0;
    }
    else {
        if ($base_idx == -1) {
            Error("Base index was never assigned for dictionary ${m}");
        }
        my $idx_bits = $dict->GetTotalNumBits();
        if (($idx_bits <= 0) || ($idx >> $idx_bits) > 1) {
            print "$idx  " . $dict->GetTotalNumBits() . "\n";
            Error("Total bits too small for dictionary ${m}");
        }
    }

    return $idx;
}


##
## EmitDictGroups --
##   Generate an array that indicates the sparse ranges of dictionary entries
##   in a tree.
##
sub EmitDictGroups($$){
    my $of = shift;
    my $dict = shift;

    my $idx = $dict->GetBaseIdx();

    print $of "    { ${idx}, " . $dict->GetNumEntries . " }";

    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        print $of ",\n";
        EmitDictGroups($of, $dict->GetDictionary($subName));
    }
}


##
## EmitDictEntryNames --
##   Emit all entry names within a dictionary and its children.
##
sub EmitDictEntryNames($$$$){
    my $of = shift;
    my $prefix = shift;
    my $dict = shift;
    my $notFirst = shift;

    foreach my $n ($dict->GetSortedEntries()) {
        if ($notFirst) {
            print $of ",\n";
        }
        $notFirst = 1;

        print $of "    \"${prefix}.${n}\"";
    }

    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitDictEntryNames($of,
                           "${prefix}.${subName}",
                           $dict->GetDictionary($subName),
                           $notFirst);
    }
}


##
## EmitDictEntryStrs --
##   Emit all entry strings within a dictionary and its children.
##
sub EmitDictEntryStrs($$$){
    my $of = shift;
    my $dict = shift;
    my $notFirst = shift;

    foreach my $n ($dict->GetSortedEntries()) {
        if ($notFirst) {
            print $of ",\n";
        }
        $notFirst = 1;

        print $of "    " . $dict->GetDefinition($n);
    }

    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitDictEntryStrs($of, $dict->GetDictionary($subName), $notFirst);
    }
}


##
## EmitH --
##   Emit one H file for specified module.
##
sub EmitH($$$) {
    my $prefix = shift;
    my $baseDict = shift;
    my $dict = shift;

    my $m = $prefix . $dict->GetName();

    my $fn = "${tgtIncDir}${m}.h";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "#ifndef __${m}_DICT_H__\n";
    print $of "#define __${m}_DICT_H__\n\n";

    ##
    ## Include sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        my $sd = $dict->GetDictionary($subName);
        print $of "#include \"awb/dict/${m}_" . $sd->GetName() . ".h\"\n";
    }
    print $of "\n";

    print $of "enum ${m}_DICT_ENUM\n";
    print $of "{\n";

    my $idx = EmitEnumValues($of, $m, "    %s_%s = %d,\n", $dict);

    print $of "};\n\n";

    my $nBitsStr = $baseDict->GetName() . "_DICT_BITS";
    my $nEntriesStr = $baseDict->GetName() . "_DICT_ENTRIES";
    print $of "#ifndef ${nBitsStr}\n";
    print $of "#define ${nBitsStr} " . $dict->GetTotalNumBits() . "\n";
    print $of "#define ${nEntriesStr} " . $dict->GetTotalNumEntries() . "\n";
    print $of "#endif // ${nBitsStr}\n";

    if ($prefix eq "") {
        print $of <<END;

class ${m}_DICT
{
  private:
    static const char * str[];
    static const char * name[];

  public:
    ${m}_DICT() {};
    ~${m}_DICT() {};

    static const char * Str(unsigned int i)
    {
        return str[i];
    };

    static const char * Name(unsigned int i)
    {
        return name[i];
    };
};
END
    }

    print $of <<END;

#endif //  __${m}_DICT_H__

#ifdef INIT_DICT
#ifndef __${m}_DICT_INIT__
#define __${m}_DICT_INIT__

END

    print $of "//\n";
    print $of "// Starting value and number of entries in dictionary ranges throughout\n";
    print $of "// the dictionary hierarchy.\n";
    print $of "//\n";
    print $of "const int nGroups${m}_DICT = " . $dict->GetNumDictionariesInTree() . ";\n";
    print $of "const int groups${m}_DICT[][2] =\n";
    print $of "{\n";
    EmitDictGroups($of, $dict);
    print $of "\n};\n\n";

    ## If top level emit entry name and string mapping arrays.
    if ($prefix eq "") {
        print $of "const char *${m}_DICT::str[] =\n";
        print $of "{\n";
        EmitDictEntryStrs($of, $dict, 0);
        print $of "\n};\n\n";

        print $of "const char *${m}_DICT::name[] =\n";
        print $of "{\n";
        EmitDictEntryNames($of, $m, $dict, 0);
        print $of "\n};\n\n";
    }

    print $of "#endif // __${m}_DICT_INIT__\n";
    print $of "#endif // INIT_DICT\n";

    undef $of;

    ##
    ## Emit sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitH("${m}_", $baseDict, $dict->GetDictionary($subName));
    }
}


##
## EmitBSH --
##   Emit one BSH file for specified module.
##
sub EmitBSH($$$);

sub EmitBSH($$$) {
    my $prefix = shift;
    my $baseDict = shift;
    my $dict = shift;

    my $m = $prefix . $dict->GetName();

    my $fn = "${tgtIncDir}${m}.bsh";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "`ifndef INCLUDED_MODULE_DICT_${m}\n";
    print $of "`define INCLUDED_MODULE_DICT_${m}\n\n";

    ##
    ## Include sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        my $sd = $dict->GetDictionary($subName);
        print $of "`include \"awb/dict/${m}_" . $sd->GetName() . ".bsh\"\n";
    }
    print $of "\n";

    my $idx = EmitEnumValues($of, $m, "`define %s_%s  %d\n", $dict);
    print $of "\n";

    my $nBitsStr = $baseDict->GetName() . "_DICT_BITS";
    my $nEntriesStr = $baseDict->GetName() . "_DICT_ENTRIES";
    print $of "`ifndef ${nBitsStr}\n";
    print $of "`define ${nEntriesStr} " . $dict->GetTotalNumEntries() . "\n";
    print $of "`define ${nBitsStr} " . $dict->GetTotalNumBits() . "\n";
    print $of "typedef Bit#(`${nBitsStr}) " . $baseDict->GetName() . "_DICT_TYPE;\n";
    print $of "`endif // ${nBitsStr}\n\n";

    ##
    ## Import must be last since it depends on definitions above!
    ##
    print $of "`ifndef IMPORTED_MODULE_DICT_${m}\n";
    print $of "import ${m}_DICT::*;\n";
    print $of "`endif\n";

    print $of "\n`endif  // INCLUDED_MODULE_DICT_${m}\n";
    undef $of;

    ##
    ## Emit sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitBSH("${m}_", $baseDict, $dict->GetDictionary($subName));
    }
}


##
## EmitBSV --
##   Emit one BSH file for specified module.
##
sub EmitBSV($$$);
sub EmitBSV_DictEntries($$$);

sub EmitBSV($$$) {
    my $prefix = shift;
    my $baseDict = shift;
    my $dict = shift;

    my $m = $prefix . $dict->GetName();

    my $fn = "${tgtHwDir}${m}_DICT.bsv";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "`define IMPORTED_MODULE_DICT_${m}\n\n";

    print $of "`include \"awb/dict/${m}.bsh\"\n\n";

    ##
    ## Describe the ranges of entries including and below this entry in the tree.
    ##
    print $of "//\n";
    print $of "// Starting value and number of entries in dictionary ranges throughout\n";
    print $of "// the dictionary hierarchy.\n";
    print $of "//\n";
    print $of "Integer nGroups${m}_DICT = " . $dict->GetNumDictionariesInTree() . ";\n";
    print $of "Integer groups${m}_DICT[nGroups${m}_DICT][2] =\n";
    print $of "{\n";
    EmitDictGroups($of, $dict);
    print $of "\n};\n\n";

    ## If top level emit entry name and string mapping arrays.
    if ($prefix eq "") {
        print $of "String str${m}_DICT[`${m}_DICT_ENTRIES] =\n";
        print $of "{\n";
        EmitDictEntryStrs($of, $dict, 0);
        print $of "\n};\n\n";

        print $of "String name${m}_DICT[`${m}_DICT_ENTRIES] =\n";
        print $of "{\n";
        EmitDictEntryNames($of, $m, $dict, 0);
        print $of "\n};\n\n";
    }

    undef $of;

    ##
    ## Emit sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitBSV("${m}_", $baseDict, $dict->GetDictionary($subName));
    }
}


sub EmitBSV_DictEntries($$$){
    my $of = shift;
    my $m = shift;
    my $dict = shift;

    foreach my $n ($dict->GetSortedEntries()) {
        print $of "        `${m}_${n}:\n";
        print $of "            return " . $dict->GetDefinition($n) . ";\n";
    }

    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitBSV_DictEntries($of, "${m}_${subName}", $dict->GetDictionary($subName));
    }
}


##
## EmitInit_Recursive --
##   Do the work for EmitInit, walking the dictionary tree recursively.
##
sub EmitInit_Recursive {
    my $of = shift;
    my $prefix = shift;
    my $dict = shift;

    my @dNames = $dict->GetSortedDictionaryNames();
    foreach my $n (@dNames) {
        my $sd = $dict->GetDictionary($n);
        my $name = $sd->GetName();

        print $of "#include \"awb/dict/${prefix}${name}.h\"\n";

        EmitInit_Recursive($of, "${prefix}${name}_", $sd);
    }
}


##
## EmitInit --
##   Emit one H file that defines all the strings.  Only one module in
##   a program should include this file.
##
sub EmitInit() {
    my $fn = "${tgtIncDir}init.h";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "#ifndef INIT_DICT\n";
    print $of "#define INIT_DICT\n";
    print $of "#endif\n\n";

    EmitInit_Recursive($of, "", $root);
}


##
## EmitModuleNames --
##   Print names of all dictionary modules.  Also print dependence info so
##   build scripts can build Bluespec modules.  To get dependence right for
##   in order parsing print the tree depth first.
##
sub EmitModuleNames {
    my $prefix = shift;
    my $dict = shift;

    my @dNames = $dict->GetSortedDictionaryNames();
    foreach my $n (@dNames) {
        my $sd = $dict->GetDictionary($n);
        my $name = $sd->GetName();

        EmitModuleNames("${prefix}${name}_", $sd);

        print "${prefix}${name}";

        my @subdNames = $sd->GetSortedDictionaryNames();
        if (@subdNames) {
            print ":";
            foreach my $sn (@subdNames) {
                print " ${prefix}${name}_${sn}";
            }
        }

        print "\n";
    }
}


###########################################################################
##
## Post-parsing analysis.  Mainly index assignment.
##
###########################################################################

##
## AssignIdxs --
##   Assign index to each sub dictionary.  Must be run after all dictionary
##   sources have been parsed.
##
my $nextIdx = 0;
my $maxEntryBits = 1;
sub AssignIdx {
    my $dict = shift;

    # Number of entries is the set of local entries plus a name for every
    # sub-entry.
    my $n_entries = $dict->GetNumEntries();

    if ($n_entries > 0) {
        $dict->SetBaseIdx($nextIdx);
        $nextIdx += $n_entries;
    }

    foreach my $n ($dict->GetSortedDictionaryNames()) {
        AssignIdx($dict->GetDictionary($n));
    }
}

##
## StoreIdxSize --
##   Simple recursive routine walks down the dictionary tree and sets the
##   minimum number of bits to store an index for the tree.  The size is the
##   same throughout the subtree.
##
sub StoreIdxSize($$$) {
    my $dict = shift;
    my $nEntries = shift;
    my $nBits = shift;

    $dict->SetTotalNumEntries($nEntries);
    $dict->SetTotalNumBits($nBits);

    foreach my $n ($dict->GetSortedDictionaryNames()) {
        StoreIdxSize($dict->GetDictionary($n), $nEntries, $nBits);
    }
}

##
## InitIdxs --
##   Initialize index numbering and sizes for each dictionary.  Each top level
##   dictionary gets its own index space, hence the assignment of 0 as the index
##   for each child of the root.  The result is a smaller numbering space
##   in the hardware.
##
sub InitIdxs() {
    my @dNames = $root->GetSortedDictionaryNames();
    foreach my $n (@dNames) {
        my $sd = $root->GetDictionary($n);
        $nextIdx = 0;
        AssignIdx($sd);
        my $n_bits = ceil(log($nextIdx + 1) / log(2));
        StoreIdxSize($sd, $nextIdx, $n_bits);
    }
}


###########################################################################
##
## Input file parsing.
##
###########################################################################

##
## AddDef --
##   Add a definition to the dictionary.
##
sub AddDef($$) {
    my $name = shift;
    my $value = shift;

    my @n = split(/\./, $name);
    if ($#n < 1) {
        Error("Illegal definition name ($name)");
    }

    # Walk down the dictionary tree to the specified level
    my $dict = $root;
    foreach my $i ( 0 .. $#n - 1 ) {
        $dict = $dict->GetOrAddDictionary($n[$i]);
    }

    # Add the definition
    if ($dict->AddDefinition($n[$#n], $value)) {
        Error("Duplicate name ($name at $n[$#n])");
    }
}

##
## QuotedString --
##   Function holding the regular expression that matches a quoted string.
##   Escaped quotes are considered part of the string.
##
sub QuotedString($)
{
    my $type = quotemeta shift;
    return qr/
        $type
        (?:
            [^$type]+
            |
            (?<= \\ ) $type
        )*
        $type
    /x;
}

##
## ParseStdToken --
##   Parse a standard token from the argument string.  Return the token
##   and the remainder of the string.
##
sub ParseStdToken($) {
    my $text = shift;

    $text =~ s/^([A-Za-z0-9_\.\[\]]+)//;
    my $tok = defined($1) ? $1 : '';
    return ($tok, $text);
}


##
## ParseLine --
##   The core of the input parser's state machine.  Parse the next token
##   from the supplied line of text.
##
use enum qw(:PARSE_ CMD DEF_MODULE DEF_VALUE SEMICOLON);
my $parseState = PARSE_CMD;
my $defModule = '';

sub ParseLine($) {
    my $text = shift;
    my $tok = '';

    return '' if ($text eq '');

    if ($parseState == PARSE_CMD) {
        ($tok, $text) = ParseStdToken($text);
        if ($tok ne 'def') {
            Error("Illegal operator");
        }
        $parseState = PARSE_DEF_MODULE;
    }
    elsif ($parseState == PARSE_DEF_MODULE) {
        ($defModule, $text) = ParseStdToken($text);
        $parseState = PARSE_DEF_VALUE;
    }
    elsif ($parseState == PARSE_DEF_VALUE) {
        $text =~ s/ ((??{ QuotedString( qq(") ) })) //x;
        my $v = $1;
        if ($v eq '') {
            Error("Expected quoted string");
        }

        ## Hack: a subscript with a constant value may be present at the end
        ## of the module name.  The parser treats "[x]" as part of a single
        ## token.  Here we emit unique names for each of the array entries.
        ## This gives a model a way of instantiating a constant number of
        ## objects based on the same name.
        if ($defModule =~ /(.*)\[([0-9]+)\]/) {
            my $mod = $1;
            my $cnt = $2;
            for (my $idx = 0; $idx < $cnt; $idx++) {
                AddDef($mod . "_$idx", $v);
            }
        }
        else {
            # Normal definition
            AddDef($defModule, $v);
        }

        $parseState = PARSE_SEMICOLON;
    }
    elsif ($parseState == PARSE_SEMICOLON) {
        if (substr($text, 0, 1) ne ';') {
            Error("Expected semicolon");
        }
        $text = substr($text, 1);
        $parseState = PARSE_CMD;
    }
    else {
        Error("Illegal parse state");
    }

    return $text;
}

##
## ParseInputFile --
##   Read text from the input file and pass it to the parser.
##
sub ParseInputFile($$) {
    my $filename = shift;
    my $updateDeps = shift;
    $fName = $filename;
    $line = 0;

    # The input file will be passed through cpp
    my $searchpath = "";
    if ($srcIncDirs ne "")
    {
        $searchpath = '-I ' . join(' -I ', split(':', $srcIncDirs));
    }

    my $host = Leap::Build::host_defs();
    my $cmd = "cpp $host $searchpath -DAWB_DEFS_ONLY";

    # First update dependence file
    if ($updateDeps)
    {
        system("$cmd -M -MT build/include/awb/rrr/service_ids.h -MF .depends-dic-" . basename($filename) . " $filename");
    }

    ## Pass the input file through cpp
    open(IF, "$cmd $filename |") || die "Failed to open $filename";

    while (<IF>) {
        chomp;
        my $d = $_;
        $line += 1;

        while ($d ne '') {
            ## Strip leading white space
            $d =~ s/^\s+//;

            ## Read cpp line number updates
            if ($d =~ /^#/) {
                my @l_info = split(' ', $d);
                if ($#l_info >= 2) {
                    $line = $l_info[1] - 1;
                    $fName = $l_info[2];
                }

                $d = '';
            }

            ## Strip comments
            $d =~ s/^\/\/.*//;

            $d = ParseLine($d);
        }
    }

    close(IF);
}


###########################################################################
##
## main
##
###########################################################################

if (! GetOptions(
          'help!'         => \$help,
          'querymodules!' => \$queryModules,
          'tgt-hw=s'      => \$tgtHwDir,
          'tgt-inc=s'     => \$tgtIncDir,
          'src-inc=s'     => \$srcIncDirs,
      )) {
    Usage(1);
}

Usage(0) if ($help);

if ($tgtHwDir ne '') {
    if (! -d $tgtHwDir) {
        print STDERR "${progName}: Target directory ${tgtHwDir} doesn't exist\n";
        exit(1);
    }
    $tgtHwDir .= '/';
}

if ($tgtIncDir ne '') {
    if (! -d $tgtIncDir) {
        print STDERR "${progName}: Target directory ${tgtIncDir} doesn't exist\n";
        exit(1);
    }
    $tgtIncDir .= '/';
}

$root = Leap::DictBuilder::new('root');

foreach my $f (@ARGV) {
    ## Parse inputs.  Only update dependence when we actually build.  (It would
    ## be fine to pick either when actually building or when querying modules.
    ## Building is less frequent, so we do it then.)
    ParseInputFile($f, ! $queryModules);
}

InitIdxs();

if ($queryModules) {
    ##
    ## Just print module names and exit
    ##
    EmitModuleNames("", $root);
    exit(0);
}

foreach my $tName ($root->GetSortedDictionaryNames()) {
    my $sd = $root->GetDictionary($tName);
    print "  Dictionary: " . $sd->GetName() . "\n";

    EmitH("", $sd, $sd);
    EmitBSH("", $sd, $sd);
    EmitBSV("", $sd, $sd);
}

EmitInit();
