#!/usr/bin/env perl
# -*- perl -*-

#
# Copyright (C) 2008 Intel Corporation
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# 
#

#
# Author: Michael Adler
#

use strict;
use Getopt::Long;
use IO::File;
use File::Basename;
use POSIX qw(ceil floor);

use Leap::DictBuilder;
use Leap::Build;
# use Data::Dumper;

#
# Turn on warnings
#
$^W = 1;

my $root;

# Debugging info
my $progName = 'leap-dict';
my $line = 0;
my $fName = '';

# Options
my $help = 0;
my $queryModules = 0;
my $tgtHwDir = '';
my $tgtIncDir = '';
my $srcIncDirs = '';

sub Error($) {
    my $msg = shift;
    print STDERR "${progName}: ${fName}:${line}, $msg\n";
    exit(1);
}

sub Usage($) {
    my $status = shift;

    print STDERR "Usage: $0 [--querymodules] [--tgt-inc <dir>] [--tgt-hw <dir>] <input files>\n";
    print STDERR "  Emit C or Bluespec data dictionaries derived from input files.\n\n";
    print STDERR "  --querymodules:  Just print the module names described in the input\n";
    print STDERR "                   files and exit.\n";
    print STDERR "  --tgt-inc <dir>: Target directory for include files.\n";
    print STDERR "  --tgt-hw  <dir>: Target directory for hw (BSV) files.\n";
    print STDERR "  --src-inc <dir>: Colon separated directory list, passed to CPP for parsing input files\n";
    exit($status);
}


###########################################################################
##
## Output file emitters
##
###########################################################################

##
## EmitHeader --
##   Emit the common header of bsh and h files.
##
sub EmitHeader($) {
    my $of = shift;

    print $of "//\n";
    print $of "// *** DO NOT EDIT ***\n";
    print $of "//\n";
    print $of "// This file is generated by $progName\n";
    print $of "//\n\n";
}


##
## EmitEnumValues --
##   Emit the dictionary name to value mappings.  This code is used by both
##   EmitH and EmitBSH.
##
sub EmitEnumValues($$$$) {
    my $of = shift;
    my $m = shift;
    my $format = shift;
    my $dict = shift;

    my $idxBits = $dict->GetTotalNumBits() - $dict->GetUIDNumBits();
    my $uid = $dict->GetUID() << $idxBits;

    my $idx = -1;
    foreach my $n ($dict->GetSortedEntries()) {
        $idx += 1;
        my $id = $idx + $uid;
        printf $of $format, $m, $n, $id;
    }

    printf $of "\n";
    printf $of $format, $m, '_BASE', $uid;
    printf $of $format, $m, '_NENTRIES', $idx + 1;

    if ($idx == -1) {
        $idx = 0;
    }
    else {
        if ($uid == -1) {
            Error("UID was never assigned for dictionary ${m}");
        }
        if (($idxBits <= 0) || ($idx >> $idxBits) != 0) {
            print "$idx  $uid  " . $dict->GetTotalNumBits() . "\n";
            Error("Total bits too small for dictionary ${m}");
        }
    }

    return $idx;
}


##
## EmitH --
##   Emit one H file for specified module.
##
sub EmitH($$$);   # Early declaration for recursion with param. checking
sub EmitH_Names($$$$$);
sub EmitH_SubDictPrint($$$$);

sub EmitH($$$) {
    my $prefix = shift;
    my $baseDict = shift;
    my $dict = shift;

    my $m = $prefix . $dict->GetName();

    my $fn = "${tgtIncDir}${m}.h";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "#ifndef __${m}_DICT_H__\n";
    print $of "#define __${m}_DICT_H__\n\n";

    ##
    ## Include sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        my $sd = $dict->GetDictionary($subName);
        print $of "#include \"awb/dict/${m}_" . $sd->GetName() . ".h\"\n";
    }
    print $of "\n";

    print $of "enum ${m}_DICT_ENUM\n";
    print $of "{\n";

    my $idx = EmitEnumValues($of, $m, "    %s_%s = %d,\n", $dict);

    print $of "};\n\n";

    my $nBitsStr = $baseDict->GetName() . "_DICT_BITS";
    my $nEntriesStr = $baseDict->GetName() . "_DICT_ENTRIES";
    print $of "#ifndef ${nBitsStr}\n";
    print $of "#define ${nBitsStr} " . $dict->GetTotalNumBits() . "\n";
    # nEntries is just 1 << nBits, not the true utilization of the numbering
    # space.  It exists for declaring arrays of the whole space.
    print $of "#define ${nEntriesStr} " . (1 << $dict->GetTotalNumBits()) . "\n";
    print $of "#endif // ${nBitsStr}\n";

    print $of <<END;

class ${m}_DICT
{
  private:
    static const char * str[];
    static const char * name[];

  public:
    ${m}_DICT() {};
    ~${m}_DICT() {};

END

    EmitH_Names($of, "Str", $idx, $m, $dict);
    print $of "\n";
    EmitH_Names($of, "Name", $idx, $m, $dict);

    print $of <<END;
};

#endif //  __${m}_DICT_H__

#ifdef INIT_DICT
#ifndef __${m}_DICT_INIT__
#define __${m}_DICT_INIT__

END

    print $of "const char *${m}_DICT::str[] =\n";
    print $of "{\n";
    foreach my $n ($dict->GetSortedEntries()) {
        print $of "    " . $dict->GetDefinition($n) . ",\n";
    }
    print $of "};\n\n";

    print $of "const char *${m}_DICT::name[] =\n";
    print $of "{\n";
    foreach my $n ($dict->GetSortedEntries()) {
        print $of "    \"" . $dict->GetName() . "_${n}\",\n";
    }
    print $of "};\n\n";

    print $of "#endif // __${m}_DICT_INIT__\n";
    print $of "#endif // INIT_DICT\n";

    undef $of;

    ##
    ## Emit sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitH("${m}_", $baseDict, $dict->GetDictionary($subName));
    }
}


sub EmitH_Names($$$$$) {
    my $of = shift;
    my $kind = shift;
    my $idx = shift;
    my $m = shift;
    my $dict = shift;

    my $var = lc($kind);

    print $of "    static const char * ${kind}(unsigned int i)\n";
    print $of "    {\n";

    my $uidBits = $dict->GetUIDNumBits();
    my $idxBits = $dict->GetTotalNumBits() - $uidBits;
    my $idxMask = (1 << $idxBits) - 1;
    my $uid = $dict->GetUID();

    if (($uid >= 0) && ($uidBits == 0)) {
        # No UIDs (single level dictionary)
        print $of "        return (i <= ${idx} ? ${var}[i] : NULL);\n";
    }
    else {
        # Using UIDs.  Find the right dictionary.
        print $of "        switch (i >> ${idxBits}) {\n";
        if ($uid >= 0) {
            print $of "          case ${uid}:\n";
            print $of "            i &= ${idxMask};\n";
            print $of "            return (i <= ${idx} ? ${var}[i] : NULL);\n";
        }

        # Add cases for subordinate dictionaries
        EmitH_SubDictPrint($of, "${m}_", $kind, $dict);

        print $of "          default:\n";
        print $of "            return NULL;\n";
        print $of "        }\n";
    }

    print $of "    };\n";
}


sub EmitH_SubDictPrint($$$$) {
    my $of = shift;
    my $prefix = shift;
    my $kind = shift;
    my $dict = shift;

    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        my $sd = $dict->GetDictionary($subName);
        my $uid = $sd->GetUID();

        if ($uid >= 0) {
            print $of "          case ${uid}:\n";
            print $of "            return ${prefix}${subName}_DICT::${kind}(i);\n";
        }

        EmitH_SubDictPrint($of, "${prefix}${subName}_", $kind, $sd);
    }
}

##
## EmitBSH --
##   Emit one BSH file for specified module.
##
sub EmitBSH($$$);

sub EmitBSH($$$) {
    my $prefix = shift;
    my $baseDict = shift;
    my $dict = shift;

    my $m = $prefix . $dict->GetName();

    my $fn = "${tgtIncDir}${m}.bsh";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "`ifndef INCLUDED_MODULE_DICT_${m}\n";
    print $of "`define INCLUDED_MODULE_DICT_${m}\n\n";

    ##
    ## Include sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        my $sd = $dict->GetDictionary($subName);
        print $of "`include \"awb/dict/${m}_" . $sd->GetName() . ".bsh\"\n";
    }
    print $of "\n";

    my $idx = EmitEnumValues($of, $m, "`define %s_%s  %d\n", $dict);
    print $of "\n";

    my $nBitsStr = $baseDict->GetName() . "_DICT_BITS";
    my $nEntriesStr = $baseDict->GetName() . "_DICT_ENTRIES";
    print $of "`ifndef ${nBitsStr}\n";
    print $of "`define ${nEntriesStr} " . (1 << $dict->GetTotalNumBits()) . "\n";
    print $of "`define ${nBitsStr} " . $dict->GetTotalNumBits() . "\n";
    print $of "typedef Bit#(`${nBitsStr}) " . $baseDict->GetName() . "_DICT_TYPE;\n";
    print $of "`endif // ${nBitsStr}\n\n";

    ##
    ## Import must be last since it depends on definitions above!
    ##
    print $of "`ifndef IMPORTED_MODULE_DICT_${m}\n";
    print $of "import ${m}_DICT::*;\n";
    print $of "`endif\n";

    print $of "\n`endif  // INCLUDED_MODULE_DICT_${m}\n";
    undef $of;

    ##
    ## Emit sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitBSH("${m}_", $baseDict, $dict->GetDictionary($subName));
    }
}


##
## EmitBSV --
##   Emit one BSH file for specified module.
##
sub EmitBSV($$$);
sub EmitBSV_DictEntries($$$);

sub EmitBSV($$$) {
    my $prefix = shift;
    my $baseDict = shift;
    my $dict = shift;

    my $m = $prefix . $dict->GetName();

    my $fn = "${tgtHwDir}${m}_DICT.bsv";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "`define IMPORTED_MODULE_DICT_${m}\n\n";

    print $of "`include \"awb/dict/${m}.bsh\"\n\n";

    ##
    ## Unlike the C++ code that emits a definition at most once, the Bluespec
    ## code replicates entries from subordinate dictionaries in the ID to
    ## string function below.  Getting the code right with BSV modules is
    ## more complicated.  In addition, this code is used only in debugging
    ## since the strings are likely to be used only for Bluesim $display
    ## debugging statements.
    ##

    print $of "function String show${m}_DICT(" . $baseDict->GetName() . "_DICT_TYPE inp);\n";
    print $of "    case (inp)\n";

    EmitBSV_DictEntries($of, $m, $dict);
    print $of "        default:\n";
    print $of "            return \"<<Undefined dictionary entry ID>>\";\n";

    print $of "    endcase\n";
    print $of "endfunction\n";

    undef $of;

    ##
    ## Emit sub dictionaries
    ##
    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitBSV("${m}_", $baseDict, $dict->GetDictionary($subName));
    }
}


sub EmitBSV_DictEntries($$$){
    my $of = shift;
    my $m = shift;
    my $dict = shift;

    foreach my $n ($dict->GetSortedEntries()) {
        print $of "        `${m}_${n}:\n";
        print $of "            return " . $dict->GetDefinition($n) . ";\n";
    }

    foreach my $subName ($dict->GetSortedDictionaryNames()) {
        EmitBSV_DictEntries($of, "${m}_${subName}", $dict->GetDictionary($subName));
    }
}


##
## EmitInit_Recursive --
##   Do the work for EmitInit, walking the dictionary tree recursively.
##
sub EmitInit_Recursive {
    my $of = shift;
    my $prefix = shift;
    my $dict = shift;

    my @dNames = $dict->GetSortedDictionaryNames();
    foreach my $n (@dNames) {
        my $sd = $dict->GetDictionary($n);
        my $name = $sd->GetName();

        print $of "#include \"awb/dict/${prefix}${name}.h\"\n";

        EmitInit_Recursive($of, "${prefix}${name}_", $sd);
    }
}


##
## EmitInit --
##   Emit one H file that defines all the strings.  Only one module in
##   a program should include this file.
##
sub EmitInit() {
    my $fn = "${tgtIncDir}init.h";
    my $of = new IO::File($fn, "w");
    die("Failed to open output file ${fn}") if (! defined($of));

    EmitHeader($of);

    print $of "#ifndef INIT_DICT\n";
    print $of "#define INIT_DICT\n";
    print $of "#endif\n\n";

    EmitInit_Recursive($of, "", $root);
}


##
## EmitModuleNames --
##   Print names of all dictionary modules.  Also print dependence info so
##   build scripts can build Bluespec modules.  To get dependence right for
##   in order parsing print the tree depth first.
##
sub EmitModuleNames {
    my $prefix = shift;
    my $dict = shift;

    my @dNames = $dict->GetSortedDictionaryNames();
    foreach my $n (@dNames) {
        my $sd = $dict->GetDictionary($n);
        my $name = $sd->GetName();

        EmitModuleNames("${prefix}${name}_", $sd);

        print "${prefix}${name}";

        my @subdNames = $sd->GetSortedDictionaryNames();
        if (@subdNames) {
            print ":";
            foreach my $sn (@subdNames) {
                print " ${prefix}${name}_${sn}";
            }
        }

        print "\n";
    }
}


###########################################################################
##
## Post-parsing analysis.  Mainly UID assignment.
##
###########################################################################

##
## AssignUIDs --
##   Assign UIDs to each sub dictionary.  Must be run after all dictionary
##   sources have been parsed.
##
my $lastUID = 0;
my $maxEntryBits = 1;
sub AssignUIDs {
    my $dict = shift;

    # This level gets a UID only if it has entries
    my @e = $dict->GetSortedEntries();
    if ($#e >= 0) {
        $dict->SetUID(++$lastUID);

        # Figure out how many bits are needed for dictionary entries
        my $nBits = ceil(log($#e + 1) / log(2));
        if ($nBits > $maxEntryBits) {
            $maxEntryBits = $nBits;
        }
    }

    foreach my $n ($dict->GetSortedDictionaryNames()) {
        AssignUIDs($dict->GetDictionary($n));
    }
}

##
## StoreUIDSize --
##   Simple recursive routine walks down the dictionary tree and sets the
##   minimum number of bits to store a UID for the tree.  The size is the
##   same throughout the subtree.
##
sub StoreUIDSize {
    my $dict = shift;
    my $nUIDBits = shift;
    my $nBits = shift;

    $dict->SetUIDNumBits($nUIDBits);
    $dict->SetTotalNumBits($nBits);

    foreach my $n ($dict->GetSortedDictionaryNames()) {
        StoreUIDSize($dict->GetDictionary($n), $nUIDBits, $nBits);
    }
}

##
## InitUIDs --
##   Initialize UID numbering and sizes for each dictionary.  Each top level
##   dictionary gets its own UID space, hence the assignment of 0 as the UID
##   for each child of the root.  The result is a smaller numbering space
##   in the hardware.
##
sub InitUIDs() {
    my @dNames = $root->GetSortedDictionaryNames();
    foreach my $n (@dNames) {
        my $sd = $root->GetDictionary($n);
        $lastUID = -1;
        AssignUIDs($sd);
        my $nBits = 0;
        if ($lastUID > 0) {
            $nBits = ceil(log($lastUID + 1) / log(2));
            $nBits = 1 if ($nBits < 1);
        }
        StoreUIDSize($sd, $nBits, $maxEntryBits + $nBits);
    }
}


###########################################################################
##
## Input file parsing.
##
###########################################################################

##
## AddDef --
##   Add a definition to the dictionary.
##
sub AddDef($$) {
    my $name = shift;
    my $value = shift;

    my @n = split(/\./, $name);
    if ($#n < 1) {
        Error("Illegal definition name ($name)");
    }

    # Walk down the dictionary tree to the specified level
    my $dict = $root;
    foreach my $i ( 0 .. $#n - 1 ) {
        $dict = $dict->GetOrAddDictionary($n[$i]);
    }

    # Add the definition
    if ($dict->AddDefinition($n[$#n], $value)) {
        Error("Duplicate name ($name at $n[$#n])");
    }
}

##
## QuotedString --
##   Function holding the regular expression that matches a quoted string.
##   Escaped quotes are considered part of the string.
##
sub QuotedString($)
{
    my $type = quotemeta shift;
    return qr/
        $type
        (?:
            [^$type]+
            |
            (?<= \\ ) $type
        )*
        $type
    /x;
}

##
## ParseStdToken --
##   Parse a standard token from the argument string.  Return the token
##   and the remainder of the string.
##
sub ParseStdToken($) {
    my $text = shift;

    $text =~ s/^([A-Za-z0-9_\.\[\]]+)//;
    my $tok = defined($1) ? $1 : '';
    return ($tok, $text);
}


##
## ParseLine --
##   The core of the input parser's state machine.  Parse the next token
##   from the supplied line of text.
##
use enum qw(:PARSE_ CMD DEF_MODULE DEF_VALUE SEMICOLON);
my $parseState = PARSE_CMD;
my $defModule = '';

sub ParseLine($) {
    my $text = shift;
    my $tok = '';

    return '' if ($text eq '');

    if ($parseState == PARSE_CMD) {
        ($tok, $text) = ParseStdToken($text);
        if ($tok ne 'def') {
            Error("Illegal operator");
        }
        $parseState = PARSE_DEF_MODULE;
    }
    elsif ($parseState == PARSE_DEF_MODULE) {
        ($defModule, $text) = ParseStdToken($text);
        $parseState = PARSE_DEF_VALUE;
    }
    elsif ($parseState == PARSE_DEF_VALUE) {
        $text =~ s/ ((??{ QuotedString( qq(") ) })) //x;
        my $v = $1;
        if ($v eq '') {
            Error("Expected quoted string");
        }

        ## Hack: a subscript with a constant value may be present at the end
        ## of the module name.  The parser treats "[x]" as part of a single
        ## token.  Here we emit unique names for each of the array entries.
        ## This gives a model a way of instantiating a constant number of
        ## objects based on the same name.
        if ($defModule =~ /(.*)\[([0-9]+)\]/) {
            my $mod = $1;
            my $cnt = $2;
            for (my $idx = 0; $idx < $cnt; $idx++) {
                AddDef($mod . "_$idx", $v);
            }
        }
        else {
            # Normal definition
            AddDef($defModule, $v);
        }

        $parseState = PARSE_SEMICOLON;
    }
    elsif ($parseState == PARSE_SEMICOLON) {
        if (substr($text, 0, 1) ne ';') {
            Error("Expected semicolon");
        }
        $text = substr($text, 1);
        $parseState = PARSE_CMD;
    }
    else {
        Error("Illegal parse state");
    }

    return $text;
}

##
## ParseInputFile --
##   Read text from the input file and pass it to the parser.
##
sub ParseInputFile($$) {
    my $filename = shift;
    my $updateDeps = shift;
    $fName = $filename;
    $line = 0;

    # The input file will be passed through cpp
    my $searchpath = "";
    if ($srcIncDirs ne "")
    {
        $searchpath = '-I ' . join(' -I ', split(':', $srcIncDirs));
    }

    my $host = Leap::Build::host_defs();
    my $cmd = "cpp $host $searchpath -DAWB_DEFS_ONLY";

    # First update dependence file
    if ($updateDeps)
    {
        system("$cmd -M -MT build/include/awb/rrr/service_ids.h -MF .depends-dic-" . basename($filename) . " $filename");
    }

    ## Pass the input file through cpp
    open(IF, "$cmd $filename |") || die "Failed to open $filename";

    while (<IF>) {
        chomp;
        my $d = $_;
        $line += 1;

        while ($d ne '') {
            ## Strip leading white space
            $d =~ s/^\s+//;

            ## Read cpp line number updates
            if ($d =~ /^#/) {
                my @l_info = split(' ', $d);
                if ($#l_info >= 2) {
                    $line = $l_info[1] - 1;
                    $fName = $l_info[2];
                }

                $d = '';
            }

            ## Strip comments
            $d =~ s/^\/\/.*//;

            $d = ParseLine($d);
        }
    }

    close(IF);
}


###########################################################################
##
## main
##
###########################################################################

if (! GetOptions(
          'help!'         => \$help,
          'querymodules!' => \$queryModules,
          'tgt-hw=s'      => \$tgtHwDir,
          'tgt-inc=s'     => \$tgtIncDir,
          'src-inc=s'     => \$srcIncDirs,
      )) {
    Usage(1);
}

Usage(0) if ($help);

if ($tgtHwDir ne '') {
    if (! -d $tgtHwDir) {
        print STDERR "${progName}: Target directory ${tgtHwDir} doesn't exist\n";
        exit(1);
    }
    $tgtHwDir .= '/';
}

if ($tgtIncDir ne '') {
    if (! -d $tgtIncDir) {
        print STDERR "${progName}: Target directory ${tgtIncDir} doesn't exist\n";
        exit(1);
    }
    $tgtIncDir .= '/';
}

$root = Leap::DictBuilder::new('root');

foreach my $f (@ARGV) {
    ## Parse inputs.  Only update dependence when we actually build.  (It would
    ## be fine to pick either when actually building or when querying modules.
    ## Building is less frequent, so we do it then.)
    ParseInputFile($f, ! $queryModules);
}

InitUIDs();

if ($queryModules) {
    ##
    ## Just print module names and exit
    ##
    EmitModuleNames("", $root);
    exit(0);
}

foreach my $tName ($root->GetSortedDictionaryNames()) {
    my $sd = $root->GetDictionary($tName);
    print "  Dictionary: " . $sd->GetName() . "\n";
    EmitBSV("", $sd, $sd);
    EmitBSH("", $sd, $sd);
    EmitH("", $sd, $sd);
}

EmitInit();
